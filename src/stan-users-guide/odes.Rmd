# Ordinary Differential Equations  {#ode-solver.chapter}

Stan provides a built-in mechanism for specifying and solving systems
of ordinary differential equations (ODEs).  Stan provides three
different integrators, tuned for solving non-stiff systems and
for stiff systems.

* `rk45`: a fourth and fifth order Runge-Kutta method for
  non-stiff systems [@DormandPrince:1980; @AhnertMulansky:2011], and

* `adams`: a variable-step, variable-order,
  Adams-Moulton formula implementation for non-stiff systems
  [@CohenHindmarsh:1996; @SerbanHindmarsh:2005]

* `bdf`: a variable-step, variable-order,
  backward-differentiation formula implementation for stiff systems
  [@CohenHindmarsh:1996; @SerbanHindmarsh:2005]

For a discussion of stiff ODE systems, see the [stiff ODE
section](#stiff-ode.section).  In a nutshell, the stiff solvers are
slower, but more robust; how much so depends on the system and the
region of parameter space.  The function signatures for Stan's ODE
solvers can be found in the reference manual section on ODE solvers.

## Example: Simple Harmonic Oscillator

As an example of a system of ODEs, consider a harmonic
oscillator, which is characterized by an equilibrium position and a
restoring force proportional to the displacement with friction.
The system state will be a pair $y = (y_1, y_2)$ representing position
and momentum: a point in phase space.  The change in the system
with respect to time is given by the following differential equations.^[This example is drawn from the documentation for the Boost Numeric Odeint library [@AhnertMulansky:2011], which Stan uses to implement the `rk45` solver.]

$$
\frac{d}{dt} y_1 = y_2
\qquad
\frac{d}{dt} y_2 = -y_1 - \theta y_2
$$
<a name="id:ode-sho.equation"></a>

The state equations implicitly define the system state at a given time
as a function of an initial state, elapsed time since the initial
state, and the system parameters.

### Solutions Given Initial Conditions {-}

Given a value of the system parameter $\theta$ and an initial state
$y(t_0)$ at time $t_0$, it is possible to simulate the evolution of
the solution numerically in order to calculate $y(t)$ for a specified
sequence of times $t_0 < t_1 < t_2 < \cdots$.

## Coding an ODE System

The simple harmonic oscillator can be coded using the following function
in Stan (see the [user-defined functions chapter](#functions-programming.chapter) for
more information on coding user-defined functions).

```
vector sho(real t,        // time
           vector y,      // state
           real theta) {
  vector[2] dydt;
  dydt[1] = y[2];
  dydt[2] = -y[1] - theta * y[2];
  return dydt;
}
```

The function takes in a time `t` (a real value), the system state
`y` (a vector), and the parameter theta. The function returns a vector
of time derivatives of the system state at time `t`, state `y`, and parameter
`theta`. The simple harmonic oscillator coded here does not have time-sensitive
equations; that is, `t` does not show up in the definition of
`dydt`, however it is still required.

### Strict Signature {-}

Every ODE system function has the same first two arguments and the
same return type. The third argument onwards can be any type, granted all
the argument types here match the types of their respective arguments in the
integrate call.

For instance, all of these are possible ODE signatures:

```
vector myode1(real t, vector y, real a0);
vector myode2(real t, vector y, int[] a0, vector a1);
vector myode3(real t, vector y, matrix a0, real[] a1, row_vector a2);
```

but these are not allowed:

```
vector myode1(real t, real[] y, real a0);
real[] myode2(real t, vector y, real a0);
vector myode3(vector y, real a0);
```

## Measurement Error Models

Statistical models or differential equations may be used to estimate
the parameters and/or initial state of a dynamic system given noisy
measurements of the system state at a finite number of time points.

For instance, suppose the simple harmonic oscillator has a parameter
value of $\theta = 0.15$ and initial state $y(t=0) = (1,0)$.  Now
suppose the system is observed at 10 time points, say $t=1, 2, ...,
10$, where each measurement of $y(t)$ has independent
$\textsf{normal}(0, 0.1)$ error in both dimensions ($y_1(t)$ and
$y_2(t)$).  A plot of such measurements is shown in the simple harmonic
oscillator trajectory plots.

Trajectory of the simple harmonic oscillator given parameter $\theta=0.15$
and initial condition $y(t=0) = (1,0)$ with additional independent
$\textsf{normal}(0,0.1)$ measurement error in both dimensions.

```{r fig.cap="Simple harmonic oscillator trajectory"}
knitr::include_graphics("img/sho-ode-trajectory.pdf")
```
<a name="id:sho-trajectory.figure"></a>


### Simulating Noisy Measurements {-}

The data used to make this plot is derived from the Stan model to
simulate noisy observations given below.

```
functions {
  vector sho(real t,
             vector y,
             real theta) {
    vector[2] dydt;
    dydt[1] = y[2];
    dydt[2] = -y[1] - theta * y[2];
    return dydt;
  }
}
data {
  int<lower=1> T;
  real y0[2];
  real t0;
  real ts[T];
  real theta;
}
model {
}
generated quantities {
  vector[2] y_hat[T] = ode_rk45(sho, y0, t0, ts, theta);
  // add measurement error
  for (t in 1:T) {
    y_hat[t, 1] += normal_rng(0, 0.1);
    y_hat[t, 2] += normal_rng(0, 0.1);
  }
}
```
<a name="id:sho-sim.figure"></a>

The system of differential equations is coded as a function.  The
system parameters `theta` and initial state `y0` are read in as data
along with the initial time `t0` and observation times `ts`. The
generated quantities block is used to solve the ODE for the specified
times and then add random measurement error, producing observations
`y_hat`.  Because the system is not stiff, the `rk45` solver is used.
Note that when the system is linear, it is a good idea to try
using the matrix exponential function, as the method can, depending
on the system at hand, yield more efficient results.

This program illustrates the way in which the ODE solver is called in
a Stan program,

```
vector[2] y_hat[T] = ode_rk45(sho, y0, t0, ts, theta);
```

this returns the solution of the ODE initial value problem defined
by system function `sho`, initial state `y0`, initial time `t0`, and
parameter `theta` at the times `ts`. The call explicitly
specifies the Runge-Kutta solver (for non-stiff systems).

Here, the ODE solver is called in the generated quantities block to
compute the solution of the ODE at `T` output times and add simulated
measurement noise using `normal_rng`.

### Estimating System Parameters and Initial State {-}

It is possible in Stan to estimate both the parameters and initial conditions.
The example below is a harmonic oscillator where both the system parameter
`theta` and initial state `y0` are parameters:

```
functions {
  vector sho(real t,
             vector y,
             real theta) {
    vector[2] dydt;
    dydt[1] = y[2];
    dydt[2] = -y[1] - theta * y[2];
    return dydt;
  }
}
data {
  int<lower=1> T;
  vector[2] y[T];
  real t0;
  real ts[T];
}
parameters {
  real y0[2];
  vector<lower=0>[2] sigma;
  real theta;
}
model {
  vector[2] y_hat[T];
  sigma ~ normal(0, 2.5);
  theta ~ std_normal();
  y0 ~ std_normal();
  y_hat = ode_rk45(sho, y0, t0, ts, theta);
  for (t in 1:T)
    y[t] ~ normal(y_hat[t], sigma);
}
```
<a name="id:sho-both.figure"></a>

Compared to the program for simulation,
the program to estimate parameters uses the `ode_rk45` function
in the model block rather than the generated quantities block.  There
are half-normal priors on the measurement error scales `sigma` and standard
normal priors on the components of parameter array `theta` and initial
state parameter array `y0`.  The solutions to the ODE are
assigned to `y_hat`, which is then used as the location in
the observation noise model as follows.

```
vector[2] y_hat[T] = ode_rk45(sho, y0, t0, ts, theta);
for (t in 1:T)
  y[t] ~ normal(y_hat[t], sigma);
```

As with other regression-like models, it's easy to change the noise
model to something with heavier tails (e.g., Student-t distributed),
correlation in the state variables (e.g., with a multivariate
normal distribution), or both heavy tails and correlation in the state
variables (e.g., with a multivariate Student-t distribution).

In this simple model, if data is generated with noise scales of 0.1, then ten
observed data points for times $t = 1,\dotsc, 10$ is sufficient to
reliably estimate the ODE parameter, initial state, and noise scales.

## Stiff ODEs {#stiff-ode.section}

Stiffness is a numerical phenomena that causes some differential equation
solvers difficulty, noteably the Runge-Kutta RK45 solver used in the examples
earlier. The phenomena is comment in chemical reaction systems, where it is
often characterized by components of the solution acting on very different
time scales.

Stan provides a specialized solver for stiff ODEs
[@CohenHindmarsh:1996; @SerbanHindmarsh:2005].  An ODE system is
specified exactly the same way with a function of exactly the same
signature.  The only difference is in the call to the integrator for
the solution; the `rk45` suffix is replaced with `bdf`, as in

```
vector[2] y_hat[T] = ode_bdf(sho, y0, t0, ts, theta);
```

Using the stiff (`bdf`) integrator on a system that is not stiff
may be much slower than using the non-stiff (`rk45`) integrator because
of the increased computational requirements of taking each time step in
with a stiff solver. On the other hand, attempting to use the non-stiff
integrator for a stiff system will cause the timestep to become very small,
leading the non-stiff solver taking more time overall even if each timestep
is easier to compute than for the stiff solver.

## Control Parameters for ODE Solving

The calls to the integrators shown above just used the default
control settings.  Both the non-stiff and stiff integrators have an additional
signature that makes it possible to specify the `relative_tolerance`,
`absolute_tolerance`, and `max_num_steps` control parameters.
All three additional arguments must be supplied if any of them is required.

```
vector[2] y_hat[T] = ode_bdf_tol(sho, y0, t0, ts,
                                 relative_tolerance,
				                         absolute_tolerance,
				                         max_num_steps,
				                         theta);
```

`relative_tolerance` and `absolute_tolerance` control the stepsize and
`max_num_steps` specifies the maximum number of steps the solver will
take between output time points before giving up.

For the RK45 solver, the default values for relative and absolute tolerance are
both $10^{-6}$ and the maximum number of steps between outputs is
one million. For the BDF and Adams solvers, the relative and absolute
tolerances are $10^{-10}$ and the maximum number of steps between outputs is
one hundred million.

### Discontinuous ODE System Function {-}

If there are discontinuities in the ODE system function, it is best
to integrate the ODE to those discontinuities, stop the solver, and
restart it on the other side.

Nonetheless, the ODE integrator will attempt to integrate over discontinuities
in the state function. The accuracy of points near the discontinuity
may be problematic (requiring many small steps).  An example of such a
discontinuity is a lag in a pharmacokinetic model, where a
concentration is going to be zero for times $0 < t < t'$ for some
lag-time $t'$, whereas it will be nonzero for times $t \geq t'$.
In this example example, we would use code in the system such as

```
if (t < t_lag)
  return 0;
else
  ... return non-zero value...;
```

In general it is better to integrate up to `t_lag` in one solve and
then integrate from `t_lag` onwards in another.

### Data only for control parameters {-}

The control parameters must be data variables---they can not be
parameters or expressions that depend on parameters, including local
variables in any block other than transformed data and generated
quantities.  User-defined function arguments may be qualified as only
allowing data arguments using the `data` qualifier.

### Tolerance {-}

The relative and absolute tolerance control the accuracy of the
solutions generated by the integrator.  Relative tolerances are
relative to the solution value, whereas absolute tolerances is the
maximum absolute error allowed in a solution.

Smaller tolerances produce more accurate solutions.  Smaller
tolerances also require more computation time.

### Maximum Number of Steps {-}

The maximum number of steps can be used to stop a runaway simulation.
This can arise in MCMC when a bad jump is taken, particularly during
warmup.  With the non-stiff solver, this may result in jumping into a
stiff region of the parameter space, which would require a  small
step size and  many steps to satisfy even modest tolerances.

## Solving a System of Linear ODEs using a Matrix Exponential

The solution to $\frac{d}{dt} y = ay$ is $y = y_0e^{at}$, where the constant
$y_0$ is determined by boundary conditions. We can extend this solution
to the vector case:
$$
\frac{d}{dt}y = A \, y
$$
<a name="id:ode.linODEs"></a>
where $y$ is now a vector of length $n$ and $A$ is an $n$ by $n$ matrix. The
solution is then given by:
$$
y = e^{tA} \, y_0
$$
<a name="id:ode.linOEs.sln"></a>
where the matrix exponential is formally defined by the convergent power series:
$$
e^{tA} = \sum_{n=0}^{\infty} \dfrac{tA^n}{n!} = I + tA + \frac{t^2A^2}{2!} + \dotsb
$$
<a name="id:ode.matrix_exp.def"></a>

We can apply this technique to the simple harmonic oscillator example, by
setting
$$
y = \begin{bmatrix} y_1 \\ y_2 \end{bmatrix} \qquad
A = \begin{bmatrix} 0 & 1 \\ -1 & -\theta \end{bmatrix}
$$
<a name="id:ode.sho_matrix"></a>

The Stan model to simulate noisy observations using a matrix exponential function
is given below. Because we are performing matrix
operations, we declare `y0` and `y_hat` as vectors, instead of using arrays,
as in the previous example code.

In general, computing a matrix exponential will be more efficient than using a numerical
solver. We can however only apply this technique to systems of linear ODEs.

```
data {
  int<lower=1> T;
  vector[2] y0;
  real ts[T];
  real theta[1];
}
model {
}
generated quantities {
  vector[2] y_hat[T];
  matrix[2, 2] A = [[ 0,  1],
                    [-1, -theta[1]]]
  for (t in 1:T)
    y_hat[t] = matrix_exp((t - 1) * A) * y0;
  // add measurement error
  for (t in 1:T) {
    y_hat[t, 1] += normal_rng(0, 0.1);
    y_hat[t, 2] += normal_rng(0, 0.1);
  }
}
```
<a name="id:sho-sim-me.figure"></a>

This Stan program simulates noisy measurements from a simple harmonic
oscillator.  The system of linear differential equations is coded as a
matrix. The system parameters `theta` and initial state `y0` are read
in as data along observation times `ts`.  The generated quantities
block is used to solve the ODE for the specified times and then add
random measurement error, producing observations `y_hat`. Because the
ODEs are linear, we can use the `matrix_exp` function to solve the
system.

#### Sensitivity Analysis {-}

The tolerances should be set low enough that setting them lower does
not change the statistical properties of posterior samples generated
by the Stan program.
