<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Stan Reference Manual</title>
  <meta name="description" content="Stan reference manual specifying the syntax and semantics of the Stan programming language.">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="Stan Reference Manual" />
  <meta property="og:type" content="book" />
  
  <meta property="og:image" content="img/logo_tm.png" />
  <meta property="og:description" content="Stan reference manual specifying the syntax and semantics of the Stan programming language." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Stan Reference Manual" />
  
  <meta name="twitter:description" content="Stan reference manual specifying the syntax and semantics of the Stan programming language." />
  <meta name="twitter:image" content="img/logo_tm.png" />

<meta name="author" content="Stan Development Team">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="expressions.html">
<link rel="next" href="blocks-chapter.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />










<link rel="stylesheet" href="../stan-manual.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li style="font-size:110%; font-weight:400; font-family: Verdana, Helvetica, sans; line-height:1.4; margin: 0.5em 0 0 1em">Stan Reference Manual</li>

<li class="divider"></li>
<li><a href="index.html#overview"><i style="font-size: 110%; padding:1.5em 0 0 0; color:#990017;">Overview</i></a></li>
<li><a href="language.html#language"><i style="font-size: 110%; color:#990017;">Language</i></a></li>
<li class="chapter" data-level="1" data-path="character-encoding.html"><a href="character-encoding.html"><i class="fa fa-check"></i><b>1</b> Character Encoding</a></li>
<li class="chapter" data-level="2" data-path="includes-section.html"><a href="includes-section.html"><i class="fa fa-check"></i><b>2</b> Includes</a></li>
<li class="chapter" data-level="3" data-path="comments-section.html"><a href="comments-section.html"><i class="fa fa-check"></i><b>3</b> Comments</a></li>
<li class="chapter" data-level="4" data-path="whitespace.html"><a href="whitespace.html"><i class="fa fa-check"></i><b>4</b> Whitespace</a></li>
<li class="chapter" data-level="5" data-path="data-types-chapter.html"><a href="data-types-chapter.html"><i class="fa fa-check"></i><b>5</b> Data Types and Declarations</a></li>
<li class="chapter" data-level="6" data-path="expressions.html"><a href="expressions.html"><i class="fa fa-check"></i><b>6</b> Expressions</a></li>
<li class="chapter" data-level="7" data-path="statements.html"><a href="statements.html"><i class="fa fa-check"></i><b>7</b> Statements</a></li>
<li class="chapter" data-level="8" data-path="blocks-chapter.html"><a href="blocks-chapter.html"><i class="fa fa-check"></i><b>8</b> Program Blocks</a></li>
<li class="chapter" data-level="9" data-path="functions-chapter.html"><a href="functions-chapter.html"><i class="fa fa-check"></i><b>9</b> User-Defined Functions</a></li>
<li class="chapter" data-level="10" data-path="variable-transforms-chapter.html"><a href="variable-transforms-chapter.html"><i class="fa fa-check"></i><b>10</b> Constraint Transforms</a></li>
<li class="chapter" data-level="11" data-path="language-syntax.html"><a href="language-syntax.html"><i class="fa fa-check"></i><b>11</b> Language Syntax</a></li>
<li class="chapter" data-level="12" data-path="program-execution.html"><a href="program-execution.html"><i class="fa fa-check"></i><b>12</b> Program Execution</a></li>
<li class="chapter" data-level="13" data-path="deprecated-features-appendix.html"><a href="deprecated-features-appendix.html"><i class="fa fa-check"></i><b>13</b> Deprecated Features</a></li>
<li><a href="algorithms.html#algorithms"><i style="font-size: 110%; color:#990017;">Algorithms</i></a></li>
<li class="chapter" data-level="14" data-path="hmc-chapter.html"><a href="hmc-chapter.html"><i class="fa fa-check"></i><b>14</b> MCMC Sampling</a></li>
<li class="chapter" data-level="15" data-path="analysis-chapter.html"><a href="analysis-chapter.html"><i class="fa fa-check"></i><b>15</b> Posterior Analysis</a></li>
<li class="chapter" data-level="16" data-path="optimization-algorithms-chapter.html"><a href="optimization-algorithms-chapter.html"><i class="fa fa-check"></i><b>16</b> Optimization</a></li>
<li class="chapter" data-level="17" data-path="vi-algorithms-chapter.html"><a href="vi-algorithms-chapter.html"><i class="fa fa-check"></i><b>17</b> Variational Inference</a></li>
<li class="chapter" data-level="18" data-path="diagnostic-algorithms-chapter.html"><a href="diagnostic-algorithms-chapter.html"><i class="fa fa-check"></i><b>18</b> Diagnostic Mode</a></li>
<li><a href="usage.html#usage"><i style="font-size: 110%; color:#990017;">Usage</i></a></li>
<li class="chapter" data-level="19" data-path="reproducibility-chapter.html"><a href="reproducibility-chapter.html"><i class="fa fa-check"></i><b>19</b> Reproducibility</a></li>
<li class="chapter" data-level="20" data-path="licensing-appendix.html"><a href="licensing-appendix.html"><i class="fa fa-check"></i><b>20</b> Licenses and Dependencies</a></li>
<li><a href="references.html#references"><i style="font-size: 110%; color:#990017;">References</i></a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Stan Reference Manual</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="statements" class="section level1">
<h1><span class="header-section-number">7</span> Statements</h1>
<p>The blocks of a Stan program are made up of
variable declarations and statements; see the <a href="#blocks">blocks chapter</a> for
details. Unlike programs in BUGS, the
declarations and statements making up a Stan program are executed in
the order in which they are written. Variables must be defined to
have some value (as well as declared to have some type) before they
are used — if they do not, the behavior is undefined.</p>
<p>The basis of Stan’s execution is the evaluation of a log probability
function (specifically, a probability density function) for a given
set of (real-valued) parameters. Log probability function can be
constructed by using assignment statements. Statements may be grouped
into sequences and into for-each loops. In addition, Stan allows
local variables to be declared in blocks and also allows an empty
statement consisting only of a semicolon.</p>
<div id="statement-block-contexts" class="section level2">
<h2><span class="header-section-number">7.1</span> Statement Block Contexts</h2>
<p>The data and parameters blocks do not allow statements of any kind
because these blocks are solely used to declare the data variables for
input and the parameter variables for sampling. All other blocks
allow statements. In these blocks, both variable declarations and
statements are allowed. The first statement that is not a variable
declaration ends the list of block variable declarations. See
the <a href="blocks-chapter.html#blocks.chapter">blocks chapter</a> for more information about the block structure of
Stan programs.</p>
</div>
<div id="assignment-statement.section" class="section level2">
<h2><span class="header-section-number">7.2</span> Assignment Statement</h2>
<p>An assignment statement consists of a variable (possibly multivariate
with indexing information) and an expression. Executing an
assignment statement evaluates the expression on the right-hand side
and assigns it to the (indexed) variable on the left-hand side.
An example of a simple assignment is as follows.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a></p>
<pre class="stan"><code>n = 0;</code></pre>
<p>Executing this statement assigns the value of the expression <code>0</code>,
which is the integer zero, to the variable <code>n</code>. For an assignment
to be well formed, the type of the expression on the right-hand side
should be compatible with the type of the (indexed) variable on the
left-hand side. For the above example, because <code>0</code> is an
expression of type <code>int</code>, the variable <code>n</code> must be declared
as being of type <code>int</code> or of type <code>real</code>. If the variable
is of type <code>real</code>, the integer zero is promoted to a
floating-point zero and assigned to the variable. After the
assignment statement executes, the variable <code>n</code> will have the
value zero (either as an integer or a floating-point value, depending on
its type).</p>
<p>Syntactically, every assignment statement must be followed by a
semicolon. Otherwise, whitespace between the tokens does not matter
(the tokens here being the left-hand-side (indexed) variable, the
assignment operator, the right-hand-side expression and the
semicolon).</p>
<p>Because the right-hand side is evaluated first, it is possible to
increment a variable in Stan just as in C++ and other programming
languages by writing</p>
<pre class="stan"><code>n = n + 1;</code></pre>
<p>Such self assignments are not allowed in BUGS, because they induce a
cycle into the directed graphical model.</p>
<p>The left-hand side of an assignment may contain indices for array,
matrix, or vector data structures. For instance, if <code>Sigma</code> is
of type <code>matrix</code>, then</p>
<pre class="stan"><code>Sigma[1, 1] = 1.0;</code></pre>
<p>sets the value in the first column of the first row of <code>Sigma</code> to one.</p>
<p>Assignments to subcomponents of larger multi-variate data structures
are supported by Stan. For example, <code>a</code> is an array of type
<code>real[ , ]</code> and <code>b</code> is an array of type <code>real[]</code>, then
the following two statements are both well-formed.</p>
<pre class="stan"><code>a[3] = b;
b = a[4];</code></pre>
<p>Similarly, if <code>x</code> is a variable declared to have type
<code>row_vector</code> and <code>Y</code> is a variable declared as type
<code>matrix</code>, then the following sequence of statements to swap the
first two rows of <code>Y</code> is well formed.</p>
<pre class="stan"><code>x = Y[1];
Y[1] = Y[2];
Y[2] = x;</code></pre>
<div id="lvalue-summary" class="section level3 unnumbered">
<h3>Lvalue Summary</h3>
<p>The expressions that are legal left-hand sides of assignment
statements are known as “lvalues.” In Stan, there are only two
kinds of legal lvalues,</p>
<ul>
<li>a variable, or</li>
<li>a variable with one or more indices.</li>
</ul>
<p>To be used as an lvalue, an indexed variable must have at least as
many dimensions as the number of indices provided. An array of real
or integer types has as many dimensions as it is declared for. A
matrix has two dimensions and a vector or row vector one dimension;
this also holds for the constrained types, covariance and correlation
matrices and their Cholesky factors and ordered, positive ordered, and
simplex vectors. An array of matrices has two more dimensions than
the array and an array of vectors or row vectors has one more
dimension than the array. Note that the number of indices can be less
than the number of dimensions of the variable, meaning that the right
hand side must itself be multidimensional to match the remaining
dimensions.</p>
</div>
<div id="multiple-indexes" class="section level3 unnumbered">
<h3>Multiple Indexes</h3>
<p>Multiple indexes, as described in the
<a href="#language-multi-indexing">multi-indexing section</a>, are also permitted on the
left-hand side of assignments. Indexing on the left side works
exactly as it does for expressions, with multiple indexes preserving
index positions and single indexes reducing them. The type on the
left side must still match the type on the right side.</p>
<div id="aliasing" class="section level4 unnumbered">
<h4>Aliasing</h4>
<p>All assignment is carried out as if the right-hand side is copied
before the assignment. This resolves any potential aliasing issues
arising from he right-hand side changing in the middle of an
assignment statement’s execution.</p>
</div>
</div>
<div id="compound-arithmetic-and-assignment-statement" class="section level3 unnumbered">
<h3>Compound Arithmetic and Assignment Statement</h3>
<p><a id="compound-arithmetic-assignment.section"></a></p>
<p>Stan’s arithmetic operators may be used in compound arithmetic
and assignment operations. For example, consider the following
example of compound addition and assignment.</p>
<pre class="stan"><code>real x = 5;
x += 7;  // value of x is now 12</code></pre>
<p>The compound arithmetic and assignment statement above is equivalent
to the following long form.</p>
<pre class="stan"><code>x = x + 7;</code></pre>
<p>In general, the compound form</p>
<pre class="stan"><code>x op= y</code></pre>
<p>will be equivalent to</p>
<pre class="stan"><code>x = x op y;</code></pre>
<p>The compound statement will be legal whenever the long form is legal.
This requires that the operation <code>x op y</code> must itself be well
formed and that the result of the operation be assignable to <code>x</code>.
For the expression <code>x</code> to be assignable, it must be an indexed
variable where the variable is defined in the current block. For
example, the following compound addition and assignment statement will
increment a single element of a vector by two.</p>
<pre class="stan"><code>vector[N] x;
x[3] += 2;</code></pre>
<p>As a further example, consider</p>
<pre class="stan"><code>matrix[M, M] x;
vector[M] y;
real z;
x *= x;  // OK, (x * x) is a matrix
x *= z;  // OK, (x * z) is a matrix
x *= y;  // BAD, (x * y) is a vector</code></pre>
<p>The supported compound arithmetic and assignment
operations are listed in the <a href="statements.html#compound-arithmetic-assign-table">compound arithmetic/assignment table</a>; they
are also listed in the index prefaced by <code>operator</code>, e.g.,
<code>operator+=</code>.</p>
<p><strong>Compound Arithmetic/Assignment Table.</strong>
<a id="compound-arithmetic-assign-table"></a>
<em>Stan allows compound arithmetic and assignment
statements of the forms listed in the table above. The compound
form is legal whenever the corresponding long form would be legal
and it has the same effect.</em></p>
<table>
<thead>
<tr class="header">
<th align="left">operation</th>
<th align="left">compound</th>
<th align="left">unfolded</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">addition</td>
<td align="left"><code>x += y</code></td>
<td align="left"><code>x = x + y</code></td>
</tr>
<tr class="even">
<td align="left">subtraction</td>
<td align="left"><code>x -= y</code></td>
<td align="left"><code>x = x - y</code></td>
</tr>
<tr class="odd">
<td align="left">multiplication</td>
<td align="left"><code>x *= y</code></td>
<td align="left"><code>x = x * y</code></td>
</tr>
<tr class="even">
<td align="left">division</td>
<td align="left"><code>x /= y</code></td>
<td align="left"><code>x = x / y</code></td>
</tr>
<tr class="odd">
<td align="left">elementwise multiplication</td>
<td align="left"><code>x .*= y</code></td>
<td align="left"><code>x = x .* y</code></td>
</tr>
<tr class="even">
<td align="left">elementwise division</td>
<td align="left"><code>x ./= y</code></td>
<td align="left"><code>x = x ./ y</code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="increment-log-prob.section" class="section level2">
<h2><span class="header-section-number">7.3</span> Increment Log Density</h2>
<p>The basis of Stan’s execution is the evaluation of a log probability
function (specifically, a probability density function) for a given
set of (real-valued) parameters; this function returns the log density
of the posterior up to an additive constant. Data and transformed
data are fixed before the log density is evaluated. The total log
probability is initialized to zero. Next, any log Jacobian
adjustments accrued by the variable constraints are added to the log
density (the Jacobian adjustment may be skipped for optimization).
Sampling and log probability increment statements may add to the log
density in the model block. A log probability increment statement
directly increments the log density with the value of an expression as
follows.<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<pre class="stan"><code>target += -0.5 * y * y;</code></pre>
<p>The keyword <code>target</code> here is actually not a variable, and may not
be accessed as such (though see below on how to access the value of
target through a special function).</p>
<p>In this example, the unnormalized log probability of a unit normal
variable <span class="math inline">\(y\)</span> is added to the total log probability. In the general
case, the argument can be any expression.<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a></p>
<p>An entire Stan model can be implemented this way. For instance, the
following model will draw a single variable according to a unit normal
probability.</p>
<pre class="stan"><code>parameters {
  real y;
}
model {
  target += -0.5 * y * y;
}</code></pre>
<p>This model defines a log probability function</p>
<p><span class="math display">\[
\log p(y) = - \, \frac{y^2}{2} - \log Z
\]</span></p>
<p>where <span class="math inline">\(Z\)</span> is a normalizing constant that does not depend on <span class="math inline">\(y\)</span>. The
constant <span class="math inline">\(Z\)</span> is conventionally written this way because on the linear
scale,
<span class="math display">\[
p(y) = \frac{1}{Z} \exp\left(-\frac{y^2}{2}\right).
\]</span>
which is typically written without reference to <span class="math inline">\(Z\)</span> as
<span class="math display">\[
p(y) \propto \exp\left(-\frac{y^2}{2}\right).
\]</span></p>
<p>Stan only requires models to be defined up to a constant that does not
depend on the parameters. This is convenient because often the
normalizing constant <span class="math inline">\(Z\)</span> is either time-consuming to compute or
intractable to evaluate.</p>
<div id="relation-to-compound-addition-and-assignment" class="section level4 unnumbered">
<h4>Relation to compound addition and assignment</h4>
<p>The increment log density statement looks syntactically like compound
addition and assignment (see the <a href="statements.html#compound-arithmetic-assignment.section">compound arithmetic/assignment section</a>, it is treated as a
primitive statement because <code>target</code> is not itself a variable.
So, even though</p>
<pre class="stan"><code>target += lp;</code></pre>
<p>is a legal statement, the corresponding long form is not legal.</p>
<pre class="stan"><code>target = target + lp;  // BAD, target is not a variable</code></pre>
</div>
<div id="vectorization" class="section level4 unnumbered">
<h4>Vectorization</h4>
<p>The <code>target += ...</code> statement accepts an argument in place of
<code>...</code> for any expression type, including integers, reals,
vectors, row vectors, matrices, and arrays of any dimensionality,
including arrays of vectors and matrices. For container arguments,
their sum will be added to the total log density.</p>
</div>
<div id="accessing-the-log-density" class="section level3 unnumbered">
<h3>Accessing the Log Density</h3>
<p>To access accumulated log density up to the current execution point,
the function <code>target()()</code> may be used.</p>
</div>
</div>
<div id="sampling-statements.section" class="section level2">
<h2><span class="header-section-number">7.4</span> Sampling Statements</h2>
<p>Stan supports writing probability statements also in sampling
notation, such as</p>
<pre class="stan"><code>y ~ normal(mu,sigma);</code></pre>
<p>The name “sampling statement” is meant to be suggestive, not
interpreted literally. Conceptually, the variable <code>y</code>, which may
be an unknown parameter or known, modeled data, is being declared
to have the distribution indicated by the right-hand side of the
sampling statement.</p>
<p>Executing such a statement does not perform any sampling. In Stan, a
sampling statement is merely a notational convenience. The above
sampling statement could be expressed as a direct increment on the
total log probability as</p>
<pre class="stan"><code>target += normal_lpdf(y | mu, sigma);</code></pre>
<p>In general, a sampling statement of the form</p>
<pre class="stan"><code>y ~ dist(theta1, ..., thetaN);</code></pre>
<p>involving subexpressions <code>y</code> and <code>theta1</code> through
<code>thetaN</code> (including the case where <code>N</code> is zero) will be well
formed if and only if the corresponding assignment statement is
well-formed. For densities allowing real <code>y</code> values, the log
probability density function is used,</p>
<pre class="stan"><code>target += dist_lpdf(y | theta1, ..., thetaN);</code></pre>
<p>For those restricted to integer <code>y</code> values, the log probability
mass function is used,</p>
<pre class="stan"><code>target += dist_lpmf(y | theta1, ..., thetaN);</code></pre>
<p>This will be well formed if and only if <code>dist_lpdf(y | theta1,   ..., thetaN)</code> or <code>dist_lpmf(y | theta1, ..., thetaN)</code> is a
well-formed expression of type <code>real</code>.</p>
<div id="log-probability-increment-vs.sampling-statement" class="section level3 unnumbered">
<h3>Log Probability Increment vs.Sampling Statement</h3>
<p>Although both lead to the same sampling behavior in Stan, there is one
critical difference between using the sampling statement, as in</p>
<pre class="stan"><code>y ~ normal(mu, sigma);</code></pre>
<p>and explicitly incrementing the log probability function, as in</p>
<pre class="stan"><code>target += normal_lpdf(y | mu,sigma);</code></pre>
<p>The sampling statement drops all the terms in the log probability
function that are constant, whereas the explicit call to
<code>normal_lpdf</code> adds all of the terms in the definition of the log
normal probability function, including all of the constant normalizing
terms. Therefore, the explicit increment form can be used to recreate
the exact log probability values for the model. Otherwise, the
sampling statement form will be faster if any of the input expressions,
<code>y</code>, <code>mu</code>, or <code>sigma</code>, involve only constants, data
variables, and transformed data variables.</p>
</div>
<div id="user-transformed-variables" class="section level3 unnumbered">
<h3>User-Transformed Variables</h3>
<p>The left-hand side of a sampling statement may be a complex
expression. For instance, it is legal syntactically to write</p>
<pre class="stan"><code>parameters {
  real&lt;lower=0&gt; beta;
}
// ...
model {
  log(beta) ~ normal(mu, sigma);
}</code></pre>
<p>Unfortunately, this is not enough to properly model <code>beta</code> as
having a lognormal distribution. Whenever a nonlinear transform is
applied to a parameter, such as the logarithm function being applied
to <code>beta</code> here, and then used on the left-hand side of a sampling
statement or on the left of a vertical bar in a log pdf function, an
adjustment must be made to account for the differential change in
scale and ensure <code>beta</code> gets the correct distribution. The
correction required is to add the log Jacobian of the transform to the
target log density; see the <a href="variable-transforms-chapter.html#change-of-variables.section">change of variables section</a> for full
definitions. For the case above, the following adjustment will
account for the log transform.<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a></p>
<pre class="stan"><code>target += - log(fabs(y));</code></pre>
</div>
<div id="truncated-distributions" class="section level3 unnumbered">
<h3>Truncated Distributions</h3>
<p>Stan supports truncating distributions with lower bounds, upper
bounds, or both.</p>
<div id="truncating-with-lower-and-upper-bounds" class="section level4 unnumbered">
<h4>Truncating with lower and upper bounds</h4>
<p>A probability density function <span class="math inline">\(p(x)\)</span> for a continuous distribution
may be truncated to an interval <span class="math inline">\([a, b]\)</span> to define a new density
<span class="math inline">\(p_{[a, b]}(x)\)</span> with support <span class="math inline">\([a, b]\)</span> by setting</p>
<p><span class="math display">\[
p_{[a, b]}(x)
= \frac{p(x)}
       {\int_a^b p(u) \, du}.
\]</span></p>
<p>A probability mass function <span class="math inline">\(p(x)\)</span> for a discrete distribution may be
truncated to the closed interval <span class="math inline">\([a, b]\)</span> by</p>
<p><span class="math display">\[
p_{[a, b]}(x) = \frac{p(x)}
                  {\sum_{u = a}^b p(u)}.
\]</span></p>
</div>
<div id="truncating-with-a-lower-bound" class="section level4 unnumbered">
<h4>Truncating with a lower bound</h4>
<p>A probability density function <span class="math inline">\(p(x)\)</span> can be truncated to <span class="math inline">\([a, \infty]\)</span> by
defining</p>
<p><span class="math display">\[
p_{[a, \infty]}(x)
= \frac{p(x)}
       {\int_a^{\infty} p(u) \, du}.
\]</span></p>
<p>A probability mass function <span class="math inline">\(p(x)\)</span> is truncated to <span class="math inline">\([a, \infty]\)</span> by
defining</p>
<p><span class="math display">\[
p_{[a, \infty]}(x) = \frac{p(x)}
                  {\sum_{a &lt;= u} p(u)}.
\]</span></p>
</div>
<div id="truncating-with-an-upper-bound" class="section level4 unnumbered">
<h4>Truncating with an upper bound</h4>
<p>A probability density function <span class="math inline">\(p(x)\)</span> can be truncated to <span class="math inline">\([-\infty, b]\)</span> by
defining</p>
<p><span class="math display">\[
p_{[-\infty, b]}(x)
= \frac{p(x)}
       {\int_{-\infty}^b p(u) \, du}.
\]</span></p>
<p>A probability mass function <span class="math inline">\(p(x)\)</span> is truncated to <span class="math inline">\([-\infty, b]\)</span> by
defining</p>
<p><span class="math display">\[
p_{[-\infty,b]}(x) = \frac{p(x)}
                  {\sum_{u &lt;= b} p(u)}.
\]</span></p>
</div>
<div id="cumulative-distribution-functions" class="section level4 unnumbered">
<h4>Cumulative distribution functions</h4>
<p>Given a probability function <span class="math inline">\(p_X(x)\)</span> for a random variable <span class="math inline">\(X\)</span>, its
cumulative distribution function (cdf) <span class="math inline">\(F_X(x)\)</span> is defined to be the
probability that <span class="math inline">\(X \leq x\)</span>,</p>
<p><span class="math display">\[
F_X(x) = \mathrm{Pr}[X \leq x].
\]</span></p>
<p>The upper-case variable <span class="math inline">\(X\)</span> is the random variable whereas the
lower-case variable <span class="math inline">\(x\)</span> is just an ordinary bound variable. For
continuous random variables, the definition of the cdf works out to</p>
<p><span class="math display">\[
F_X(x) \ = \ \int_{-\infty}^{x} p_X(u) \, du,
\]</span></p>
<p>For discrete variables, the cdf is defined to include the upper bound
given by the argument,</p>
<p><span class="math display">\[
F_X(x) = \sum_{u \leq x} p_X(u).
\]</span></p>
</div>
<div id="complementary-cumulative-distribution-functions" class="section level4 unnumbered">
<h4>Complementary cumulative distribution functions</h4>
<p>The complementary cumulative distribution function (ccdf) in both the
continuous and discrete cases is given by</p>
<p><span class="math display">\[
F^C_X(x)
\ = \ \mathrm{Pr}[X &gt; x]
\ = \ 1 - F_X(x).
\]</span></p>
<p>Unlike the cdf, the ccdf is exclusive of the bound, hence the event
<span class="math inline">\(X &gt; x\)</span> rather than the cdf’s event <span class="math inline">\(X \leq x\)</span>.</p>
<p>For continuous distributions, the ccdf works out to</p>
<p><span class="math display">\[
F^C_X(x)
\ = \ 1 - \int_{-\infty}^x p_X(u) \, du
\ = \ \int_x^{\infty} p_X(u) \, du.
\]</span></p>
<p>The lower boundary can be included in the integration bounds because
it is a single point on a line and hence has no probability mass.
For the discrete case, the lower bound must be excluded in the
summation explicitly by summing over <span class="math inline">\(u &gt; x\)</span>,</p>
<p><span class="math display">\[
F^C_X(x)
\ = \ 1 - \sum_{u \leq x} p_X(u)
\ = \ \sum_{u &gt; x} p_X(u).
\]</span></p>
<p>Cumulative distribution functions provide the necessary integral
calculations to define truncated distributions. For truncation with
lower and upper bounds, the denominator is defined by
<span class="math display">\[
\int_a^b p(u) \, du = F_X(b) - F_X(a).
\]</span>
This allows truncated distributions to be defined as
<span class="math display">\[
p_{[a,b]}(x) = \frac{p_X(x)}
                  {F_X(b) - F_X(a)}.
\]</span></p>
<p>For discrete distributions, a slightly more complicated form is
required to explicitly insert the lower truncation point, which is
otherwise excluded from <span class="math inline">\(F_X(b) - F_X(a)\)</span>,</p>
<p><span class="math display">\[
p_{[a,b]}(x) = \frac{p_X(x)}
                  {F_X(b) - F_X(a) + p_X(a)}.
\]</span></p>
</div>
<div id="truncation-with-lower-and-upper-bounds-in-stan" class="section level4 unnumbered">
<h4>Truncation with lower and upper bounds in Stan</h4>
<p>Stan allows probability functions to be truncated. For example, a
truncated unit normal distributions restricted to <span class="math inline">\([-0.5, 2.1]\)</span>
can be coded with the following sampling statement.</p>
<pre class="stan"><code>y ~ normal(0, 1) T[-0.5, 2.1];</code></pre>
<p>Truncated distributions are translated as an additional term in the
accumulated log density function plus error checking to make sure the
variate in the sampling statement is within the bounds of the
truncation.</p>
<p>In general, the truncation bounds and parameters may be parameters or
local variables.</p>
<p>Because the example above involves a continuous distribution, it
behaves the same way as the following more verbose form.</p>
<pre class="stan"><code>y ~ normal(0, 1);
if (y &lt; -0.5 || y &gt; 2.1)
  target += negative_infinity();
else
  target += -log_diff_exp(normal_lcdf(2.1 | 0, 1),
                          normal_lcdf(-0.5 | 0, 1));</code></pre>
<p>Because a Stan program defines a log density function, all
calculations are on the log scale. The function <code>normal_lcdf</code>
is the log of the cumulative normal distribution function and the
function <code>log_diff_exp(a, b)</code> is a more arithmetically stable
form of <code>log(exp(a) - exp(b))</code>.</p>
<p>For a discrete distribution, another term is necessary in the
denominator to account for the excluded boundary. The truncated
discrete distribution</p>
<pre class="stan"><code>y ~ poisson(3.7) T[2, 10];</code></pre>
<p>behaves in the same way as the following code.</p>
<pre class="stan"><code>y ~ poisson(3.7);
if (y &lt; 2 || y &gt; 10)
  target += negative_infinity();
else
  target += -log_sum_exp(poisson_lpmf(2 | 3.7),
                         log_diff_exp(poisson_lcdf(10 | 3.7),
                                      poisson_lcdf(2 | 3.7)));</code></pre>
<p>Recall that <code>log_sum_exp(a, b)</code> is just the arithmetically stable form
of <code>log(exp(a) + exp(b))</code>.</p>
</div>
<div id="truncation-with-lower-bounds-in-stan" class="section level4 unnumbered">
<h4>Truncation with lower bounds in Stan</h4>
<p>For truncating with only a lower bound, the upper limit is left blank.</p>
<pre class="stan"><code>y ~ normal(0, 1) T[-0.5, ];</code></pre>
<p>This truncated sampling statement has the same behavior as the
following code.</p>
<pre class="stan"><code>y ~ normal(0, 1);
if (y &lt; -0.5)
  target += negative_infinity();
else
  target += -normal_lccdf(-0.5 | 0, 1);</code></pre>
<p>The <code>normal_lccdf</code> function is the normal complementary cumulative
distribution function.</p>
<p>As with lower and upper truncation, the discrete case requires a more
complicated denominator to add back in the probability mass for the
lower bound. Thus</p>
<pre class="stan"><code>y ~ poisson(3.7) T[2, ];</code></pre>
<p>behaves the same way as</p>
<pre class="stan"><code>y ~ poisson(3.7);
if (y &lt; 2)
  target += negative_infinity();
else
  target += -log_sum_exp(poisson_lpmf(2 | 3.7),
                         poisson_lccdf(2 | 3.7));</code></pre>
</div>
<div id="truncation-with-upper-bounds-in-stan" class="section level4 unnumbered">
<h4>Truncation with upper bounds in Stan</h4>
<p>To truncate with only an upper bound, the lower bound is left blank.
The upper truncated sampling statement</p>
<pre class="stan"><code>y ~ normal(0, 1) T[ , 2.1];</code></pre>
<p>produces the same result as the following code.</p>
<pre class="stan"><code>target += normal_lpdf(y | 0, 1);
if (y &gt; 2.1)
  target += negative_infinity();
else
  target += -normal_lcdf(2.1 | 0, 1);</code></pre>
<p>With only an upper bound, the discrete case does not need a boundary
adjustment. The upper-truncated sampling statement</p>
<pre class="stan"><code>y ~ poisson(3.7) T[ , 10];</code></pre>
<p>behaves the same way as the following code.</p>
<pre class="stan"><code>y ~ poisson(3.7);
if (y &gt; 10)
  target += negative_infinity();
else
  target += -poisson_lcdf(10 | 3.7);</code></pre>
</div>
<div id="cumulative-distributions-must-be-defined" class="section level4 unnumbered">
<h4>Cumulative distributions must be defined</h4>
<p>In all cases, the truncation is only well formed if the appropriate
log density or mass function and necessary log cumulative distribution
functions are defined. Not every distribution built into Stan has log
cdf and log ccdfs defined, nor will every user-defined distribution. The
discrete probability function documentations describes
the available discrete
and continuous cumulative distribution functions; most univariate
distributions have log cdf and log ccdf functions.</p>
</div>
<div id="type-constraints-on-bounds" class="section level4 unnumbered">
<h4>Type constraints on bounds</h4>
<p>For continuous distributions, truncation points must be expressions of
type <code>int</code> or <code>real</code>. For discrete distributions, truncation
points must be expressions of type <code>int</code>.</p>
</div>
<div id="variates-outside-of-truncation-bounds" class="section level4 unnumbered">
<h4>Variates outside of truncation bounds</h4>
<p>For a truncated sampling statement, if the value sampled is not within
the bounds specified by the truncation expression, the result is zero
probability and the entire statement adds <span class="math inline">\(-\infty\)</span> to the total log
probability, which in turn results in the sample being rejected.</p>
</div>
<div id="vectorizing-truncated-distributions" class="section level4 unnumbered">
<h4>Vectorizing Truncated Distributions</h4>
<p>Stan does not (yet) support vectorization of distribution functions
with truncation.</p>
</div>
</div>
</div>
<div id="for-loops" class="section level2">
<h2><span class="header-section-number">7.5</span> For Loops</h2>
<p>Suppose <code>N</code> is a variable of type <code>int</code>, <code>y</code> is a one-dimensional
array of type <code>real[]</code>, and <code>mu</code> and <code>sigma</code> are variables of type
<code>real</code>. Furthermore, suppose that <code>n</code> has not been defined as a
variable. Then the following is a well-formed for-loop statement.</p>
<pre class="stan"><code>for (n in 1:N) {
  y[n] ~ normal(mu, sigma);
}</code></pre>
<p>The loop variable is <code>n</code>, the loop bounds are the values in the
range <code>1:N</code>, and the body is the statement following the
loop bounds.</p>
<div id="loop-variable-typing-and-scope" class="section level3 unnumbered">
<h3>Loop Variable Typing and Scope</h3>
<p>The bounds in a for loop must be integers. Unlike in R, the loop is
always interpreted as an upward counting loop. The range <code>L:H</code>
will cause the loop to execute the loop with the loop variable taking
on all integer values greater than or equal to <code>L</code> and less than
or equal to <code>H</code>. For example, the loop <code>for (n in 2:5)</code>
will cause the body of the for loop to be executed with <code>n</code> equal
to 2, 3, 4, and 5, in order. The variable and bound <code>for (n in   5:2)</code> will not execute anything because there are no integers
greater than or equal to 5 and less than or equal to 2.</p>
</div>
<div id="order-sensitivity-and-repeated-variables" class="section level3 unnumbered">
<h3>Order Sensitivity and Repeated Variables</h3>
<p>Unlike in BUGS, Stan allows variables to be reassigned. For
example, the variable <code>theta</code> in the following program is
reassigned in each iteration of the loop.</p>
<pre class="stan"><code>for (n in 1:N) {
  theta = inv_logit(alpha + x[n] * beta);
  y[n] ~ bernoulli(theta);
}</code></pre>
<p>Such reassignment is not permitted in BUGS. In BUGS, for loops are
declarative, defining plates in directed graphical model notation,
which can be thought of as repeated substructures in the graphical
model. Therefore, it is illegal in BUGS or JAGS to have a for loop
that repeatedly reassigns a value to a variable.<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a></p>
<p>In Stan, assignments are executed in the order they are encountered.
As a consequence, the following Stan program has a very different
interpretation than the previous one.</p>
<pre class="stan"><code>for (n in 1:N) {
  y[n] ~ bernoulli(theta);
  theta = inv_logit(alpha + x[n] * beta);
}</code></pre>
<p>In this program, <code>theta</code> is assigned after it is used in the
probability statement. This presupposes it was defined before the
first loop iteration (otherwise behavior is undefined), and then each
loop uses the assignment from the previous iteration.</p>
<p>Stan loops may be used to accumulate values. Thus it is possible to
sum the values of an array directly using code such as the following.</p>
<pre class="stan"><code>total = 0.0;
for (n in 1:N)
  total = total + x[n];</code></pre>
<p>After the for loop is executed, the variable <code>total</code> will hold
the sum of the elements in the array <code>x</code>. This example was
purely pedagogical; it is easier and more efficient to write</p>
<pre class="stan"><code>total = sum(x);</code></pre>
<p>A variable inside (or outside) a loop may even be reassigned multiple
times, as in the following legal code.</p>
<pre class="stan"><code>for (n in 1:100) {
  y += y * epsilon;
  epsilon = 0.5 * epsilon;
  y += y * epsilon;
}</code></pre>
</div>
</div>
<div id="foreach-loops" class="section level2">
<h2><span class="header-section-number">7.6</span> Foreach Loops</h2>
<p>A second form of for loops allows iteration over elements of
containers. If <code>ys</code> is an expression denoting a container (vector,
row vector, matrix, or array) with elements of type <code>T</code>, then the
following is a well-formed foreach statement.</p>
<pre><code>for (y in ys) {
  ... do something with y ...
}</code></pre>
<p>The order in which elements of <code>ys</code> are visited is defined for container types as follows.</p>
<ul>
<li><p><code>vector</code>, <code>row_vector</code>: elements visited in order, <code>y</code> is of type <code>double</code></p></li>
<li><p><code>matrix</code>: elements visited in column-major order, <code>y</code> is of type <code>double</code></p></li>
<li><p><code>T[]</code>: elements visited in order, <code>y</code> is of type <code>T</code>.</p></li>
</ul>
<p>Consequently, if <code>ys</code> is a two dimensional array <code>real[ , ]</code>, <code>y</code> will
be a one-dimensional array of real values (type <code>real[]</code>). If ’ys<code>is a matrix, then</code>y<code>will be a real value (type</code>real`). To loop over
all values of a two-dimensional array using foreach statements would
require a doubly-nested loop,</p>
<pre><code>real yss[2, 3];
for (ys in yss)
  for (y in ys)
    ... do something with y ...</code></pre>
<p>whereas a matrix can be looped over in one foreach statement</p>
<pre><code>matrix[2, 3] yss;
for (y in yss)
   ... do something with y...</code></pre>
<p>In both cases, the loop variable <code>y</code> is of type <code>real.  The elements of the matrix are visited in column-major order (e.g.,</code>y[1, 1]<code>,</code>y[2, 1]<code>,</code>y[1, 2]<code>, ...,</code>y[2, 3]<code>), whereas the elements of the two-dimensionl array are visited in row-major order (e.g.,</code>y[1, 1]<code>,</code>y[1, 2]<code>,</code>y[1, 3]<code>,</code>y[2, 1]<code>, ...,</code>y[2, 3]`).</p>
</div>
<div id="conditional-statements" class="section level2">
<h2><span class="header-section-number">7.7</span> Conditional Statements</h2>
<p>Stan supports full conditional statements using
the same if-then-else syntax as C++. The general format is</p>
<pre class="stan"><code>if (condition1)
  statement1
else if (condition2)
  statement2
// ...
else if (conditionN-1)
  statementN-1
else
  statementN</code></pre>
<p>There must be a single leading <code>if</code> clause, which may be followed
by any number of <code>else if</code> clauses, all of which may be
optionally followed by an <code>else</code> clause. Each condition must be
a real or integer value, with non-zero values interpreted as true and
the zero value as false.</p>
<p>The entire sequence of if-then-else clauses forms a single conditional
statement for evaluation. The conditions are evaluated in order
until one of the conditions evaluates to a non-zero value, at which
point its corresponding statement is executed and the conditional
statement finishes execution. If none of the conditions evaluates to
a non-zero value and there is a final else clause, its statement is
executed.</p>
</div>
<div id="while-statements" class="section level2">
<h2><span class="header-section-number">7.8</span> While Statements</h2>
<p>Stan supports standard while loops using the same syntax as C++. The
general format is as follows.</p>
<pre class="stan"><code>while (condition)
  body</code></pre>
<p>The condition must be an integer or real expression and the body can
be any statement (or sequence of statements in curly braces).</p>
<p>Evaluation of a while loop starts by evaluating the condition. If the
condition evaluates to a false (zero) value, the execution of the loop
terminates and control moves to the position after the loop. If the
loop’s condition evaluates to a true (non-zero) value, the body statement is
executed, then the whole loop is executed again. Thus the loop is
continually executed as long as the condition evaluates to a true value.</p>
<p>The rest of the body of a while loop may be skipped using a
<code>continue</code>. The loop will be exited with a <code>break</code> statement. See
the <a href="statements.html#break-continue-statements">section on continue and break
statements</a> for more details.</p>
</div>
<div id="statement-blocks-and-local-variable-declarations" class="section level2">
<h2><span class="header-section-number">7.9</span> Statement Blocks and Local Variable Declarations</h2>
<p>Just as parentheses may be used to group expressions, curly brackets
may be used to group a sequence of zero or more statements into a
statement block. At the beginning of each block, local variables may be
declared that are scoped over the rest of the statements in the block.</p>
<div id="blocks-in-for-loops" class="section level3 unnumbered">
<h3>Blocks in For Loops</h3>
<p>Blocks are often used to group a sequence of statements together to be
used in the body of a for loop. Because the body of a for loop can be
any statement, for loops with bodies consisting of a single statement
can be written as follows.</p>
<pre class="stan"><code>for (n in 1:N)
  y[n] ~ normal(mu,sigma);</code></pre>
<p>To put multiple statements inside the body of a for loop, a block is
used, as in the following example.</p>
<pre class="stan"><code>for (n in 1:N) {
  lambda[n] ~ gamma(alpha,beta);
  y[n] ~ poisson(lambda[n]);
}</code></pre>
<p>The open curly bracket (<code>\{</code>) is the first character of the block
and the close curly bracket (<code>\</code>}) is the last character.</p>
<p>Because whitespace is ignored in Stan, the following program will
not compile.</p>
<pre class="stan"><code>for (n in 1:N)
  y[n] ~ normal(mu, sigma);
  z[n] ~ normal(mu, sigma); // ERROR!</code></pre>
<p>The problem is that the body of the for loop is taken to be the
statement directly following it, which is
<code>y[n] ~ normal(mu,sigma)</code>. This leaves the probability statement for
<code>z[n]</code> hanging, as is clear from the following equivalent
program.</p>
<pre class="stan"><code>for (n in 1:N) {
  y[n] ~ normal(mu, sigma);
}
z[n] ~ normal(mu, sigma); // ERROR!</code></pre>
<p>Neither of these programs will compile. If the loop variable <code>n</code>
was defined before the for loop, the for-loop declaration will raise
an error. If the loop variable <code>n</code> was not defined before the
for loop, then the use of the expression <code>z[n]</code> will raise an
error.</p>
</div>
<div id="local-variable-declarations" class="section level3 unnumbered">
<h3>Local Variable Declarations</h3>
<p>A for loop has a statement as a body. It is often convenient in
writing programs to be able to define a local variable that will be
used temporarily and then forgotten. For instance, the for loop
example of repeated assignment should use a local variable for maximum
clarity and efficiency, as in the following example.</p>
<pre class="stan"><code>for (n in 1:N) {
  real theta;
  theta = inv_logit(alpha + x[n] * beta);
  y[n] ~ bernoulli(theta);
}</code></pre>
<p>The local variable <code>theta</code> is declared here inside the for loop.
The scope of a local variable is just the block in which it is
defined. Thus <code>theta</code> is available for use inside the for loop,
but not outside of it. As in other situations, Stan does not allow
variable hiding. So it is illegal to declare a local variable
<code>theta</code> if the variable theta is already defined in the scope of
the for loop. For instance, the following is not legal.</p>
<pre class="stan"><code>for (m in 1:M) {
  real theta;
  for (n in 1:N) {
    real theta; // ERROR!
    theta = inv_logit(alpha + x[m, n] * beta);
    y[m, n] ~ bernoulli(theta);
// ...</code></pre>
<p>The compiler will flag the second declaration of <code>theta</code> with a
message that it is already defined.</p>
</div>
<div id="no-constraints-on-local-variables" class="section level3 unnumbered">
<h3>No Constraints on Local Variables</h3>
<p>Local variables may not have constraints on their declaration. The
only types that may be used are</p>
<pre><code>int, real, vector[K], row_vector[K], matrix[M, N].</code></pre>
</div>
<div id="blocks-within-blocks" class="section level3 unnumbered">
<h3>Blocks within Blocks</h3>
<p>A block is itself a statement, so anywhere a sequence of statements is
allowed, one or more of the statements may be a block. For instance,
in a for loop, it is legal to have the following</p>
<pre class="stan"><code>for (m in 1:M) {
  {
     int n = 2 * m;
     sum += n;
  }
  for (n in 1:N)
    sum += x[m, n];
}</code></pre>
<p>The variable declaration <code>int n;</code> is the first element of an
embedded block and so has scope within that block. The for loop
defines its own local block implicitly over the statement following it
in which the loop variable is defined. As far as Stan is concerned,
these two uses of <code>n</code> are unrelated.</p>
</div>
</div>
<div id="break-and-continue-statements" class="section level2">
<h2><span class="header-section-number">7.10</span> Break and Continue Statements <a id="break-continue-statements"></a></h2>
<p>The one-token statements <code>continue</code> and <code>break</code> may be used
within loops to alter control flow; <code>continue</code> causes the next
iteration of the loop to run immediately, whereas <code>break</code>
terminates the loop and causes execution to resume after the loop.
Both control structures must appear in loops. Both <code>break</code> and
<code>continue</code> scope to the most deeply nested loop, but pass through
non-loop statements.</p>
<p>Although these control statements may seem undesirable because of
their goto-like behavior, their judicious use can greatly improve
readability by reducing the level of nesting or eliminating bookkeeping
inside loops.</p>
<div id="break-statements" class="section level3 unnumbered">
<h3>Break Statements</h3>
<p>When a <code>break</code> statement is executed, the most deeply nested loop
currently being executed is ended and execution picks up with the next
statement after the loop. For example, consider the following
program:</p>
<pre class="stan"><code>while (1) {
  if (n &lt; 0) break;
  foo(n);
  n = n - 1;
}</code></pre>
<p>The <code>while~(1)</code> loop is a “forever” loop, because <code>1</code> is
the true value, so the test always succeeds. Within the loop, if the
value of <code>n</code> is less than 0, the loop terminates, otherwise it
executes <code>foo(n)</code> and then decrements <code>n</code>. The statement
above does exactly the same thing as</p>
<pre class="stan"><code>while (n &gt;= 0) {
  foo(n);
  n = n - 1;
}</code></pre>
<p>This case is simply illustrative of the behavior; it is not a case
where a <code>break</code> simplifies the loop.</p>
</div>
<div id="continue-statements" class="section level3 unnumbered">
<h3>Continue Statements</h3>
<p>The <code>continue</code> statement ends the current operation of the loop
and returns to the condition at the top of the loop. Such loops are
typically used to exclude some values from calculations. For example,
we could use the following loop to sum the positive values in the
array <code>x</code>,</p>
<pre class="stan"><code>real sum;
sum = 0;
for (n in 1:size(x)) {
  if (x[n] &lt;= 0) continue;
  sum += x[n];
}</code></pre>
<p>When the continue statement is executed, control jumps back to the
conditional part of the loop. With while and for loops, this causes
control to return to the conditional of the loop. With for loops,
this advances the loop variable, so the the above program will not go
into an infinite loop when faced with an <code>x[n]</code> less than zero.
Thus the above program could be rewritten with deeper nesting by
reversing the conditional,</p>
<pre class="stan"><code>real sum;
sum = 0;
for (n in 1:size(x)) {
  if (x[n] &gt; 0)
    sum += x[n];
}</code></pre>
<p>While the latter form may seem more readable in this simple case, the
former has the main line of execution nested one level less deep.
Instead, the conditional at the top finds cases to exclude and doesn’t
require the same level of nesting for code that’s not excluded. When
there are several such exclusion conditions, the break or continue
versions tend to be much easier to read.</p>
</div>
<div id="breaking-and-continuing-nested-loops" class="section level3 unnumbered">
<h3>Breaking and Continuing Nested Loops</h3>
<p>If there is a loop nested within a loop, a <code>break</code> or
<code>continue</code> statement only breaks out of the inner loop. So</p>
<pre class="stan"><code>while (cond1) {
  ...
  while (cond2) {
    ...
    if (cond3) break;
    ...
  }
  // execution continues here after break
  ...
}</code></pre>
<p>If the break is triggered by <code>cond3</code> being true, execution will
continue after the nested loop.</p>
<p>As with break statements, continue statements go back to the top of
the most deeply nested loop in which the <code>continue</code> appears.</p>
<p>Although break and continue must appear within loops, they may appear
in nested statements within loops, such as within the conditionals
shown above or within nested statements. The break and continue
statements jump past any control structure other than while-loops and
for-loops.</p>
</div>
</div>
<div id="print-statements.section" class="section level2">
<h2><span class="header-section-number">7.11</span> Print Statements</h2>
<p>Stan provides print statements that can print literal strings and the
values of expressions. Print statements accept any number of
arguments. Consider the following for-each statement with a print
statement in its body.</p>
<pre class="stan"><code>for (n in 1:N) { print(&quot;loop iteration: &quot;, n); ... }</code></pre>
<p>The print statement will execute every time the body of the loop does.
Each time the loop body is executed, it will print the string “loop
iteration:” (with the trailing space), followed by the value of the
expression <code>n</code>, followed by a new line.</p>
<div id="print-content" class="section level3 unnumbered">
<h3>Print Content</h3>
<p>The text printed by a print statement varies based on its content. A
literal (i.e., quoted) string in a print statement always prints
exactly that string (without the quotes). Expressions in print
statements result in the value of the expression being printed.
But how the value of the expression is formatted will depend on its type.</p>
<p>Printing a simple <code>real</code> or <code>int</code> typed variable always
prints the variable’s value.<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a></p>
<p>For array, vector, and matrix variables, the print format uses
brackets. For example, a 3-vector will print as</p>
<pre class="stan"><code>[1, 2, 3]</code></pre>
<p>and a <span class="math inline">\(2 \times 3\)</span>-matrix as</p>
<pre class="stan"><code>[[1, 2, 3], [4, 5, 6]]</code></pre>
<p>Printing a more readable version of arrays or matrices can be done
with loops. An example is the print statement in the following
transformed data block.</p>
<pre class="stan"><code>transformed data {
  matrix[2, 2] u;
  u[1, 1] = 1.0;   u[1, 2] = 4.0;
  u[2, 1] = 9.0;   u[2, 2] = 16.0;
  for (n in 1:2)
    print(&quot;u[&quot;, n, &quot;] = &quot;, u[n]);
}</code></pre>
<p>This print statement executes twice, printing the following two lines
of output.</p>
<pre class="stan"><code>u[1] = [1, 4]
u[2] = [9, 16]</code></pre>
</div>
<div id="non-void-input" class="section level3 unnumbered">
<h3>Non-void Input</h3>
<p>The input type to a print function cannot be void. In particular, it
can’t be the result of a user-defined void function. All other types
are allowed as arguments to the print function.</p>
</div>
<div id="print-frequency" class="section level3 unnumbered">
<h3>Print Frequency</h3>
<p>Printing for a print statement happens every time it is executed. The
<code>transformed data</code> block is executed once per chain, the
<code>transformed parameter</code> and <code>model</code> blocks once per leapfrog
step, and the <code>generated quantities</code> block once per iteration.</p>
</div>
<div id="string-literals" class="section level3 unnumbered">
<h3>String Literals</h3>
<p>String literals begin and end with a double quote character
(<code>&quot;</code>). The characters between the double quote characters may be
the space character or any visible ASCII character, with the exception
of the backslash character (<code>\</code>) and double quote character
(<code>&quot;</code>). The full list of visible ASCII characters is as follows,</p>
<pre><code>a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9 0 { } [ ] ( ) &lt; &gt;
~ @ # $ ` ^ &amp; * _ &#39; - + = | / ! ? . , ; :</code></pre>
</div>
<div id="debug-by-print" class="section level3 unnumbered">
<h3>Debug by <code>print</code></h3>
<p>Because Stan is an imperative language, print statements can be very
useful for debugging. They can be used to display the values of
variables or expressions at various points in the execution of a
program. They are particularly useful for spotting problematic
not-a-number of infinite values, both of which will be printed.</p>
<p>It is particularly useful to print the value of the target log
density accumulator (through the <code>target()</code> function), as in the following example.</p>
<pre class="stan"><code>vector[2] y;
y[1] = 1;
print(&quot;log density before =&quot;, target());
y ~ normal(0,1);  // bug!  y[2] not defined
print(&quot;log density after =&quot;, target());</code></pre>
<p>The example has a bug in that <code>y[2]</code> is not defined before the
vector <code>y</code> is used in the sampling statement. By printing the
value of the log probability accumulator before and after each
sampling statement, it’s possible to isolate where the log probability
becomes ill-defined (i.e., becomes not-a-number).</p>
</div>
</div>
<div id="reject-statements.section" class="section level2">
<h2><span class="header-section-number">7.12</span> Reject Statements</h2>
<p>The Stan <code>reject</code> statement provides a mechanism to
report errors or problematic values encountered during program
execution and either halt processing or reject iterations.</p>
<p>Like the <code>print</code> statement, the reject statement accepts
any number of quoted string literals or Stan expressions as arguments.</p>
<p>Reject statements are typically embedded in a conditional
statement in order to detect variables in illegal states. For
example, the following code handles the case where a variable <code>x</code>’s
value is negative.</p>
<pre class="stan"><code>if (x &lt; 0)
  reject(&quot;x must not be negative; found x=&quot;, x);</code></pre>
<div id="behavior-of-reject-statements" class="section level3 unnumbered">
<h3>Behavior of Reject Statements</h3>
<p>Reject statements have the same behavior as exceptions thrown by
built-in Stan functions. For example, the <code>normal_lpdf</code> function
raises an exception if the input scale is not positive and finite.
The effect of a reject statement depends on the program block in which
the rejection occurs.</p>
<p>In all cases of rejection, the interface accessing the Stan
program should print the arguments to the reject statement.</p>
<div id="rejections-in-functions" class="section level4 unnumbered">
<h4>Rejections in Functions</h4>
<p>Rejections in user-defined functions are just passed to the
calling function or program block. Reject statements can be used in
functions to validate the function arguments, allowing user-defined
functions to fully emulate built-in function behavior. It is better
to find out earlier rather than later when there is a problem.</p>
</div>
<div id="fatal-exception-contexts" class="section level4 unnumbered">
<h4>Fatal Exception Contexts</h4>
<p>In both the transformed data block and generated quantities block,
rejections are fatal. This is because if initialization fails or if
generating output fails, there is no way to recover values.</p>
<p>Reject statements placed in the transformed data block can be used
to validate both the data and transformed data (if any). This allows
more complicated constraints to be enforced that can be specified with
Stan’s constrained variable declarations.</p>
</div>
<div id="recoverable-rejection-contexts" class="section level4 unnumbered">
<h4>Recoverable Rejection Contexts</h4>
<p>Rejections in the transformed parameters and model blocks are
not in and of themselves instantly fatal. The result has the same
effect as assigning a <span class="math inline">\(-\infty\)</span> log probability, which causes
rejection of the current proposal in MCMC samplers and adjustment of
search parameters in optimization.</p>
<p>If the log probability function results in a rejection every time it is
called, the containing application (MCMC sampler or optimization)
should diagnose this problem and terminate with an appropriate error
message. To aid in diagnosing problems, the message for each
reject statement will be printed as a result of executing it.</p>
</div>
</div>
<div id="rejection-is-not-for-constraints" class="section level3 unnumbered">
<h3>Rejection is not for Constraints</h3>
<p>Rejection should be used for error handling, not defining arbitrary
constraints. Consider the following errorful Stan program.</p>
<pre class="stan"><code>parameters {
  real a;
  real&lt;lower=a&gt; b;
  real&lt;lower=a, upper=b&gt; theta;
  ...
model {
  // **wrong** needs explicit truncation
  theta ~ normal(0, 1);
  ...</code></pre>
<p>This program is wrong because its truncation bounds on <code>theta</code>
depend on parameters, and thus need to be accounted for using an
explicit truncation on the distribution. This is the right way to do
it.</p>
<pre class="stan"><code>  theta ~ normal(0, 1) T[a, b];</code></pre>
<p>The conceptual issue is that the prior does not integrate to one over
the admissible parameter space; it integrates to one over all real
numbers and integrates to something less than one over <span class="math inline">\([a ,b]\)</span>; in
these simple univariate cases, we can overcome that with the
<code>T[ , ]</code> notation, which essentially divides by whatever the
prior integrates to over <span class="math inline">\([a, b]\)</span>.</p>
<p>This problem is exactly the same problem as you would get using reject
statements to enforce complicated inequalities on multivariate
functions. In this case, it is wrong to try to deal with truncation
through constraints.</p>
<pre class="stan"><code>  if (theta &lt; a || theta &gt; b)
    reject(&quot;theta not in (a, b)&quot;);
  // still **wrong**, needs T[a,b]
  theta ~ normal(0, 1);</code></pre>
<p>In this case, the prior integrates to something less than one over the
region of the parameter space where the complicated inequalities are
satisfied. But we don’t generally know what value the prior integrates
to, so we can’t increment the log probability function to compensate.</p>
<p>Even if this adjustment to a proper probability model may seem minor
in particular models where the amount of truncated posterior density
is negligible or constant, we can’t sample from that truncated
posterior efficiently. Programs need to use one-to-one mappings that
guarantee the constraints are satisfied and only use reject statements
to raise errors or help with debugging.</p>

</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="5">
<li id="fn5"><p>In versions of Stan before 2.18.0, the operator <code>&lt;-</code> was used for assignment rather than using the equal sign <code>=</code>. The old operator <code>&lt;-</code> is now deprecated and will print a warning. In the future, it will be removed.<a href="statements.html#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>The current notation replaces two previous versions. Originally, a variable <code>lp__</code> was directly exposed and manipulated; this is no longer allowed. The original statement syntax for <code>target += u</code> was <code>increment_log_prob(u)</code>, but this form has been deprecated and will be removed in Stan 3.<a href="statements.html#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>Writing this model with the expression <code>-0.5 * y * y</code> is more efficient than with the equivalent expression <code>y * y / -2</code> because multiplication is more efficient than division; in both cases, the negation is rolled into the numeric literal (<code>-0.5</code> and <code>-2</code>). Writing <code>square(y)</code> instead of <code>y * y</code> would be even more efficient because the derivatives can be precomputed, reducing the memory and number of operations required for automatic differentiation.<a href="statements.html#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p>Because <span class="math inline">\(\log | \frac{d}{dy} \log y | = \log | 1/y | = - \log |y|\)</span>.<a href="statements.html#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p>A programming idiom
in BUGS code simulates a local variable by replacing <code>theta</code> in the
above example with <code>theta[n]</code>, effectively creating <code>N</code> different
variables, <code>theta[1]</code>, …, <code>theta[N]</code>. Of course, this is not a hack
if the value of <code>theta[n]</code> is required for all <code>n</code>.<a href="statements.html#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p>The adjoint component is always zero during execution for the algorithmic differentiation variables used to implement parameters, transformed parameters, and local variables in the model.<a href="statements.html#fnref10" class="footnote-back">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="expressions.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="blocks-chapter.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": null,
"fontsettings": {
"theme": "white",
"family": "serif",
"size": 2
},
"edit": null,
"download": null,
"toc": {
"collapse": "section",
"scroll_highlight": true
},
"search": false,
"toolbar": {
"position": "static"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
