<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Bayesian Statistics Using Stan</title>
  <meta name="description" content="Bayesian Statistics Using Stan, including Stan user’s guide with examples and programming techniques.">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="Bayesian Statistics Using Stan" />
  <meta property="og:type" content="book" />
  
  <meta property="og:image" content="img/logo-tm.pdf" />
  <meta property="og:description" content="Bayesian Statistics Using Stan, including Stan user’s guide with examples and programming techniques." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Bayesian Statistics Using Stan" />
  
  <meta name="twitter:description" content="Bayesian Statistics Using Stan, including Stan user’s guide with examples and programming techniques." />
  <meta name="twitter:image" content="img/logo-tm.pdf" />

<meta name="author" content="Stan Development Team">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="algebra-solver-chapter.html">
<link rel="next" href="part-3-programming-techniques.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="stan-manual.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li style="font-size:110%; font-weight:400; font-family: Verdana, Helvetica, sans; line-height:1.4; margin: 0.5em 0 0 1em">Bayesian Statistics with Stan</li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>About this Book</a></li>
<li><a href="part-1-overview.html#part-1-overview"><i style="font-size: 110%; padding:1.5em 0 0 0; color:#990017;">Part 1: Overview</i></a></li>
<li class="chapter" data-level="1" data-path="introduction.html"><a href="introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a></li>
<li class="chapter" data-level="2" data-path="prior-distributions-and-models-for-data.html"><a href="prior-distributions-and-models-for-data.html"><i class="fa fa-check"></i><b>2</b> Prior Distributions and Models for Data</a></li>
<li class="chapter" data-level="3" data-path="simple-examples.html"><a href="simple-examples.html"><i class="fa fa-check"></i><b>3</b> Simple Examples</a></li>
<li class="chapter" data-level="4" data-path="bayesian-workflow-1.html"><a href="bayesian-workflow-1.html"><i class="fa fa-check"></i><b>4</b> Bayesian Workflow</a></li>
<li><a href="example-models-part.html#example-models.part"><i style="font-size: 110%; color:#990017;">Part 2. Example Models</i></span></a></li>
<li class="chapter" data-level="5" data-path="regression-models.html"><a href="regression-models.html"><i class="fa fa-check"></i><b>5</b> Regression Models</a></li>
<li class="chapter" data-level="6" data-path="time-series-chapter.html"><a href="time-series-chapter.html"><i class="fa fa-check"></i><b>6</b> Time-Series Models</a></li>
<li class="chapter" data-level="7" data-path="missing-data-and-partially-known-parameters.html"><a href="missing-data-and-partially-known-parameters.html"><i class="fa fa-check"></i><b>7</b> Missing Data and Partially Known Parameters</a></li>
<li class="chapter" data-level="8" data-path="floating-point-arithmetic.html"><a href="floating-point-arithmetic.html"><i class="fa fa-check"></i><b>8</b> Floating Point Arithmetic</a></li>
<li class="chapter" data-level="9" data-path="truncated-or-censored-data.html"><a href="truncated-or-censored-data.html"><i class="fa fa-check"></i><b>9</b> Truncated or Censored Data</a></li>
<li class="chapter" data-level="10" data-path="mixture-modeling-chapter.html"><a href="mixture-modeling-chapter.html"><i class="fa fa-check"></i><b>10</b> Finite Mixtures</a></li>
<li class="chapter" data-level="11" data-path="measurement-error-and-meta-analysis.html"><a href="measurement-error-and-meta-analysis.html"><i class="fa fa-check"></i><b>11</b> Measurement Error and Meta-Analysis</a></li>
<li class="chapter" data-level="12" data-path="latent-discrete-chapter.html"><a href="latent-discrete-chapter.html"><i class="fa fa-check"></i><b>12</b> Latent Discrete Parameters</a></li>
<li class="chapter" data-level="13" data-path="sparse-ragged-chapter.html"><a href="sparse-ragged-chapter.html"><i class="fa fa-check"></i><b>13</b> Sparse and Ragged Data Structures</a></li>
<li class="chapter" data-level="14" data-path="clustering-chapter.html"><a href="clustering-chapter.html"><i class="fa fa-check"></i><b>14</b> Clustering Models</a></li>
<li class="chapter" data-level="15" data-path="gaussian-processes-chapter.html"><a href="gaussian-processes-chapter.html"><i class="fa fa-check"></i><b>15</b> Gaussian Processes</a></li>
<li class="chapter" data-level="16" data-path="directions-rotations-and-hyperspheres.html"><a href="directions-rotations-and-hyperspheres.html"><i class="fa fa-check"></i><b>16</b> Directions, Rotations, and Hyperspheres</a></li>
<li class="chapter" data-level="17" data-path="algebra-solver-chapter.html"><a href="algebra-solver-chapter.html"><i class="fa fa-check"></i><b>17</b> Solving Algebraic Equations</a></li>
<li class="chapter" data-level="18" data-path="ode-solver-chapter.html"><a href="ode-solver-chapter.html"><i class="fa fa-check"></i><b>18</b> Ordinary Differential Equations</a></li>
<li><a href="part-3-programming-techniques.html#part-3.-programming-techniques"><i style="font-size: 110%; color:#990017;">Part 3. Programming Techniques</i></a></li>
<li class="chapter" data-level="19" data-path="modeling-as-software-development.html"><a href="modeling-as-software-development.html"><i class="fa fa-check"></i><b>19</b> Modeling as Software Development</a></li>
<li class="chapter" data-level="20" data-path="matrices-vectors-and-arrays.html"><a href="matrices-vectors-and-arrays.html"><i class="fa fa-check"></i><b>20</b> Matrices, Vectors, and Arrays</a></li>
<li class="chapter" data-level="21" data-path="multi-indexing-chapter.html"><a href="multi-indexing-chapter.html"><i class="fa fa-check"></i><b>21</b> Multiple Indexing and Range Indexing</a></li>
<li class="chapter" data-level="22" data-path="functions-programming-chapter.html"><a href="functions-programming-chapter.html"><i class="fa fa-check"></i><b>22</b> User-Defined Functions</a></li>
<li class="chapter" data-level="23" data-path="custom-probability-functions-chapter.html"><a href="custom-probability-functions-chapter.html"><i class="fa fa-check"></i><b>23</b> Custom Probability Functions</a></li>
<li class="chapter" data-level="24" data-path="problematic-posteriors-chapter.html"><a href="problematic-posteriors-chapter.html"><i class="fa fa-check"></i><b>24</b> Problematic Posteriors</a></li>
<li class="chapter" data-level="25" data-path="change-of-variables-chapter.html"><a href="change-of-variables-chapter.html"><i class="fa fa-check"></i><b>25</b> Reparameterization and Change of Variables</a></li>
<li class="chapter" data-level="26" data-path="optimization-chapter.html"><a href="optimization-chapter.html"><i class="fa fa-check"></i><b>26</b> Efficiency Tuning</a></li>
<li class="chapter" data-level="27" data-path="map-reduce-chapter.html"><a href="map-reduce-chapter.html"><i class="fa fa-check"></i><b>27</b> Map-Reduce</a></li>
<li><a href="part-4-review-of-statistical-inference.html#part-4-review-of-statistical-inference"><i style="font-size: 110%; color:#990017;">Part 4: Review of Statistical Inference</i></a></li>
<li class="chapter" data-level="28" data-path="bayesian-data-analysis-1.html"><a href="bayesian-data-analysis-1.html"><i class="fa fa-check"></i><b>28</b> Bayesian Data Analysis</a></li>
<li class="chapter" data-level="29" data-path="mle-chapter.html"><a href="mle-chapter.html"><i class="fa fa-check"></i><b>29</b> Penalized Maximum Likelihood Point Estimation</a></li>
<li class="chapter" data-level="30" data-path="bayesian-point-estimation.html"><a href="bayesian-point-estimation.html"><i class="fa fa-check"></i><b>30</b> Bayesian Point Estimation</a></li>
<li class="chapter" data-level="31" data-path="vi-advanced-chapter.html"><a href="vi-advanced-chapter.html"><i class="fa fa-check"></i><b>31</b> Variational Inference</a></li>
<li><a href="appendices.html#appendices"><i style="font-size: 110%; color:#990017;">Appendices</i></a></li>
<li class="chapter" data-level="" data-path="appendix-1-stan-program-style-guide.html"><a href="appendix-1-stan-program-style-guide.html"><i class="fa fa-check"></i>Appendix 1. Stan Program Style Guide</a></li>
<li class="chapter" data-level="" data-path="stan-for-bugs-appendix.html"><a href="stan-for-bugs-appendix.html"><i class="fa fa-check"></i>Appendix 2. Transitioning from BUGS</a></li>
<li><a href="references.html#references"><i style="font-size: 110%; color:#990017;">References</i></a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Bayesian Statistics Using Stan</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="ode-solver.chapter" class="section level1">
<h1><span class="header-section-number">18</span> Ordinary Differential Equations</h1>
<p>Stan provides a built-in mechanism for specifying and solving systems
of ordinary differential equations (ODEs). Stan provides two
different integrators, one tuned for solving non-stiff systems and one
for stiff systems.</p>
<ul>
<li><p><code>rk45</code>: a fourth and fifth order Runge-Kutta method for
non-stiff systems <span class="citation">(Dormand and Prince <a href="#ref-DormandPrince:1980">1980</a>; Ahnert and Mulansky <a href="#ref-AhnertMulansky:2011">2011</a>)</span>, and</p></li>
<li><p><code>bdf</code>: a variable-step, variable-order,
backward-differentiation formula implementation for stiff systems
<span class="citation">(Cohen and Hindmarsh <a href="#ref-CohenHindmarsh:1996">1996</a>; Serban and Hindmarsh <a href="#ref-SerbanHindmarsh:2005">2005</a>)</span></p></li>
</ul>
<p>For a discussion of stiff ODE systems, see the <a href="ode-solver-chapter.html#stiff-ode.section">stiff ODE
section</a>. In a nutshell, the stiff solvers are
slower, but more robust; how much so depends on the system and the
region of parameter space. The function signatures for Stan’s ODE
solvers can be found in the reference manual section on ODE solvers.</p>
<div id="example-simple-harmonic-oscillator" class="section level2">
<h2><span class="header-section-number">18.1</span> Example: Simple Harmonic Oscillator</h2>
<p>As an example of a system of ODEs, consider a harmonic
oscillator, which is characterized by an equilibrium position and a
restoring force proportional to the displacement with friction.
The system state will be a pair <span class="math inline">\(y = (y_1, y_2)\)</span> representing position
and momentum: a point in phase space. The change in the system
with respect to time is given by the following differential equations.<a href="#fn27" class="footnote-ref" id="fnref27"><sup>27</sup></a></p>
<p><span class="math display">\[
\frac{d}{dt} y_1 = y_2
\ \ \ \ \ \ \ \ \ \ \
\frac{d}{dt} y_2 = -y_1 - \theta y_2
\]</span>
id:ode-sho.equation</p>
<p>The state equations implicitly define the system state at a given time
as a function of an initial state, elapsed time since the initial
state, and the system parameters.</p>
<div id="solutions-given-initial-conditions" class="section level3 unnumbered">
<h3>Solutions Given Initial Conditions</h3>
<p>Given a value of the system parameter <span class="math inline">\(\theta\)</span> and an initial state
<span class="math inline">\(y(t_0)\)</span> at time <span class="math inline">\(t_0\)</span>, it is possible to simulate the evolution of
the solution numerically in order to calculate <span class="math inline">\(y(t)\)</span> for a specified
sequence of times <span class="math inline">\(t_0 &lt; t_1 &lt; t_2 &lt; \cdots\)</span>.</p>
</div>
</div>
<div id="coding-an-ode-system" class="section level2">
<h2><span class="header-section-number">18.2</span> Coding an ODE System</h2>
<p>A system of ODEs is coded directly in Stan as a function with a
strictly specified signature. For example, the simple harmonic
oscillator can be coded using the following function in Stan (see the
<a href="functions-programming-chapter.html#functions-programming.chapter">user-defined functions chapter</a> for
more information on coding user-defined functions).</p>
<pre><code>real[] sho(real t,        // time
           real[] y,      // state
           real[] theta,  // parameters
           real[] x_r,    // data (real)
           int[] x_i) {   // data (integer)
  real dydt[2];
  dydt[1] = y[2];
  dydt[2] = -y[1] - theta[1] * y[2];
  return dydt;
}</code></pre>
<p>The function takes in a time <code>t</code> (a real value), a a system state
<code>y</code> (real array), system parameters <code>theta</code> (a real array),
along with real data in variable <code>x_r</code> (a real array) and
integer data in variable <code>x_i</code> (an integer array). The system
function returns the array of derivatives of the system state with
respect to time, evaluated at time <code>t</code> and state <code>y</code>. The
simple harmonic oscillator coded here does not have time-sensitive
equations; that is, <code>t</code> does not show up in the definition of
<code>dydt</code>. The simple harmonic oscillator does not use real or
integer data, either. Nevertheless, these unused arguments must be
included as arguments in the system function with exactly the
signature shown above.</p>
<div id="strict-signature-1" class="section level3 unnumbered">
<h3>Strict Signature</h3>
<p>The function defining the system must have exactly these argument
types and return type. This may require passing in zero-length arrays
for data or parameters if the system does not involve data or
parameters. A full example for the simple harmonic oscillator, which
does not depend on any constant data variables, is provided in the
simple harmonic oscillator trajectory plot.</p>
</div>
<div id="discontinuous-ode-system-function" class="section level3 unnumbered">
<h3>Discontinuous ODE System Function</h3>
<p>The ODE integrator is able to integrate over discontinuities in the
state function, although the accuracy of points near the discontinuity
may be problematic (requiring many small steps). An example of such a
discontinuity is a lag in a pharmacokinetic model, where a
concentration is going to be zero for times <span class="math inline">\(0 &lt; t &lt; t&#39;\)</span> for some
lag-time <span class="math inline">\(t&#39;\)</span>, whereas it will be nonzero for times <span class="math inline">\(t \geq t&#39;\)</span>. As
an example, would involve code in the system such as</p>
<pre><code>if (t &lt; t_lag)
  return 0;
else
  ... return non-zero value...;</code></pre>
</div>
<div id="varying-initial-time" class="section level3 unnumbered">
<h3>Varying Initial Time</h3>
<p>Stan’s ODE solvers require the initial time argument to be a constant
(i.e., a function of data or transformed data variables and
constants). This means that, in general, there’s no way to use the
<code>integrate_ode</code> function to accept a parameter for the initial
time and thus no way in general to estimate the initial time of an ODE
system from measurements.</p>
</div>
</div>
<div id="solving-a-system-of-linear-odes-using-a-matrix-exponential" class="section level2">
<h2><span class="header-section-number">18.3</span> Solving a System of Linear ODEs using a Matrix Exponential</h2>
<p>The solution to <span class="math inline">\(\frac{d}{dt} y = ay\)</span> is <span class="math inline">\(y = y_0e^{at}\)</span>, where the constant
<span class="math inline">\(y_0\)</span> is determined by boundary conditions. We can extend this solution
to the vector case:</p>
<p><span class="math display">\[
\frac{d}{dt}y = A y
\]</span>
id:ode.linODEs</p>
<p>where <span class="math inline">\(y\)</span> is now a vector of length <span class="math inline">\(n\)</span> and <span class="math inline">\(A\)</span> is an <span class="math inline">\(n\)</span> by <span class="math inline">\(n\)</span> matrix. The
solution is then given by:</p>
<p><span class="math display">\[
y = e^{tA}y_0
\]</span>
id:ode.linOEs.sln</p>
<p>where the matrix exponential is formally defined by the convergent power series:</p>
<p><span class="math display">\[
e^{tA} = \sum_{n=0}^{\infty} \dfrac{tA^n}{n!} = I + tA + \frac{t^2A^2}{2!} + ...
\]</span>
id:ode.matrix_exp.def</p>
<p>We can apply this technique to the simple harmonic oscillator example, by
setting</p>
<p><span class="math display">\[
  y = \left[\begin{array}{c}
        y_1 \\
        y_2 \\
        \end{array}\right] \ \ \ \ \
   A = \left[\begin{array}{cc}
    0 &amp; 1 \\
    -1 &amp; -\theta \\
    \end{array}\right]
\]</span>
id:ode.sho_matrix</p>
<p>The Stan model to simulate noisy observations using a matrix exponential function
is given below. Because we are performing matrix
operations, we declare <code>y0</code> and <code>y_hat</code> as vectors, instead of using arrays,
as in the previous example code.</p>
<p>In general, computing a matrix exponential will be more efficient than using a numerical
solver. We can however only apply this technique to systems of  ODEs.</p>
<pre><code>data {
  int&lt;lower=1&gt; T;
  vector[2] y0;
  real ts[T];
  real theta[1];
}
model {
}
generated quantities {
  vector[2] y_hat[T];
  matrix[2, 2] A = [[ 0,  1],
                    [-1, -theta[1]]]
  for (t in 1:T)
    y_hat[t] = matrix_exp((t - 1) * A) * y0;
  // add measurement error
  for (t in 1:T) {
    y_hat[t, 1] += normal_rng(0, 0.1);
    y_hat[t, 2] += normal_rng(0, 0.1);
  }
}</code></pre>
<p>id:sho-sim-me.figure</p>
<p>This Stan program simulates noisy measurements from a simple harmonic
oscillator. The system of linear differential equations is coded as a
matrix. The system parameters <code>theta</code> and initial state <code>y0</code> are read
in as data along observation times <code>ts</code>. The generated quantities
block is used to solve the ODE for the specified times and then add
random measurement error, producing observations <code>y_hat</code>. Because the
ODEs are linear, we can use the <code>matrix_exp</code> function to solve the
system.</p>
</div>
<div id="measurement-error-models" class="section level2">
<h2><span class="header-section-number">18.4</span> Measurement Error Models</h2>
<p>Statistical models or differential equations may be used to estimate
the parameters and/or initial state of a dynamic system given noisy
measurements of the system state at a finite number of time points.</p>
<p>For instance, suppose the simple harmonic oscillator has a parameter
value of <span class="math inline">\(\theta = 0.15\)</span> and initial state <span class="math inline">\(y(t=0) = (1,0)\)</span>. Now
suppose the system is observed at 10 time points, say <span class="math inline">\(t=1, 2, ..., 10\)</span>, where each measurement of <span class="math inline">\(y(t)\)</span> has independent
<span class="math inline">\(\mathsf{normal}(0, 0.1)\)</span> error in both dimensions (<span class="math inline">\(y_1(t)\)</span> and
<span class="math inline">\(y_2(t)\)</span>). A plot of such measurements is shown in the simple harmonic
oscillator trajectory plots.</p>
<p>Trajectory of the simple harmonic oscillator given parameter <span class="math inline">\(\theta=0.15\)</span> and initial condition <span class="math inline">\(y(t=0) = (1,0)\)</span> with additional independent <span class="math inline">\(\mathsf{normal}(0,0.1)\)</span> measurement error in both dimensions.</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-2"></span>
<img src="img/sho-ode-trajectory.pdf" alt="Simple harmonic oscillator trajectory" width="70%" />
<p class="caption">
Figure 18.1: Simple harmonic oscillator trajectory
</p>
</div>
<p>id:sho-trajectory.figure</p>
<div id="simulating-noisy-measurements" class="section level3 unnumbered">
<h3>Simulating Noisy Measurements</h3>
<p>The data used to make this plot is derived from the Stan model to
simulate noisy observations given below.</p>
<pre><code>functions {
  real[] sho(real t,
             real[] y,
             real[] theta,
             real[] x_r,
             int[] x_i) {
    real dydt[2];
    dydt[1] = y[2];
    dydt[2] = -y[1] - theta[1] * y[2];
    return dydt;
  }
}
data {
  int&lt;lower=1&gt; T;
  real y0[2];
  real t0;
  real ts[T];
  real theta[1];
}
transformed data {
  real x_r[0];
  int x_i[0];
}
model {
}
generated quantities {
  real y_hat[T,2] = integrate_ode_rk45(sho, y0, t0, ts, theta, x_r, x_i);
  // add measurement error
  for (t in 1:T) {
    y_hat[t, 1] += normal_rng(0, 0.1);
    y_hat[t, 2] += normal_rng(0, 0.1);
  }
}</code></pre>
<p>id:sho-sim.figure</p>
<p>The system of differential equations is coded as a function. The
system parameters <code>theta</code> and initial state <code>y0</code> are read in as data
along with the initial time <code>t0</code> and observation times <code>ts</code>. The
generated quantities block is used to solve the ODE for the specified
times and then add random measurement error, producing observations
<code>y_hat</code>. Because the system is not stiff, the <code>rk45</code> solver is used.</p>
<p>This program illustrates the way in which the ODE solver is called in
a Stan program,</p>
<pre><code>y_hat = integrate_ode_rk45(sho, y0, t0, ts, theta, x_r, x_i);</code></pre>
<p>This assigns the solutions to the system defined by function
<code>sho</code>, given initial state <code>y0</code>, initial time <code>t0</code>,
requested solution times <code>ts</code>, parameters <code>theta</code>, real data
<code>x</code>, and integer data <code>x_int</code>. The call explicitly
specifies the Runge-Kutta solver (for non-stiff systems).</p>
<p>Here, the ODE solver is called in the generated quantities block to
provide a <span class="math inline">\(10 \times 2\)</span> array of solutions <code>y_hat</code> to
which measurement error is added using the normal pseudo-random number
generating function <code>normal_rng</code>. The number of rows in the
solution array is the same as the size of <code>ts</code>, the requested
solution times.</p>
</div>
<div id="data-versus-parameters-1" class="section level3 unnumbered">
<h3>Data versus Parameters</h3>
<p>Unlike other functions, the integration functions for ODEs are limited
as to the origins of variables in their arguments. In particular, the
time <code>t</code>, real data <code>x</code>, and integer data <code>x_int</code> must
be expressions that only involve data or transformed data variables.
The initial state <code>y</code> or the parameters <code>theta</code> are the only
arguments which may involve parameters.</p>
</div>
<div id="estimating-system-parameters-and-initial-state" class="section level3 unnumbered">
<h3>Estimating System Parameters and Initial State</h3>
<p>Stan provides statistical inference for unknown initial states and/or
parameters. The ODE solver will be used deterministically to produce
predictions, much like the linear predictor does in a generalized
linear model. These states will then be observed with measurement error.</p>
<pre><code>functions {
  real[] sho(real t,
             real[] y,
             real[] theta,
             real[] x_r,
             int[] x_i) {
    real dydt[2];
    dydt[1] = y[2];
    dydt[2] = -y[1] - theta[1] * y[2];
    return dydt;
  }
}
data {
  int&lt;lower=1&gt; T;
  real y[T,2];
  real t0;
  real ts[T];
}
transformed data {
  real x_r[0];
  int x_i[0];
}
parameters {
  real y0[2];
  vector&lt;lower=0&gt;[2] sigma;
  real theta[1];
}
model {
  real y_hat[T,2];
  sigma ~ cauchy(0, 2.5);
  theta ~ std_normal();
  y0 ~ std_normal();
  y_hat = integrate_ode_rk45(sho, y0, t0, ts, theta, x_r, x_i);
  for (t in 1:T)
    y[t] ~ normal(y_hat[t], sigma);
}</code></pre>
<p>id:sho-both.figure</p>
<p>This Stan program allows estimates of unknown initial conditions <code>y0</code>
and system parameter <code>theta</code> for the simple harmonic oscillator with
independent normal measurement error.</p>
<p>A Stan program that can be used to estimate both the initial state and
parameter value for the simple harmonic oscillator given noisy
observations is given above. Compared to the program for simulation,
the program to estimate parameters uses the <code>integrate_ode</code> function
in the model block rather than the generated quantities block. There
are Cauchy priors on the measurement error scales <code>sigma</code> and standard
normal priors on the components of parameter array <code>theta</code> and initial
state parameter array <code>y0</code>. The solutions to the ODE are then
assigned to an array <code>y_hat</code>, which is then used as the location in
the observation noise model as follows.</p>
<pre><code>y_hat = integrate_ode_rk45(sho, y0, t0, ts, theta, x_r, x_i);
for (t in 1:T)
  y[t] ~ normal(y_hat[t], sigma);</code></pre>
<p>As with other regression-like models, it’s easy to change the noise
model to be robust (e.g., Student-t distributed), to be correlated in
the state variables (e.g., with a multivariate normal distribution),
or both (e.g., with a multivariate Student-t distribution).</p>
<p>In this simple model with independent noise scales of 0.10, 10
observed data points for times <span class="math inline">\(t = 1, ..., 10\)</span> is sufficient to
reliably estimate the ODE parameter, initial state, and noise scales.</p>
</div>
</div>
<div id="stiff-ode.section" class="section level2">
<h2><span class="header-section-number">18.5</span> Stiff ODEs</h2>
<p>A stiff system of ordinary differential equations can be roughly
characterized as systems presenting numerical difficulties for
gradient-based stepwise solvers. Stiffness typically arises due to
varying curvature in the dimensions of the state, for instance one
component evolving orders of magnitude more slowly than another.<a href="#fn28" class="footnote-ref" id="fnref28"><sup>28</sup></a></p>
<p>Stan provides a specialized solver for stiff ODEs
<span class="citation">(Cohen and Hindmarsh <a href="#ref-CohenHindmarsh:1996">1996</a>; Serban and Hindmarsh <a href="#ref-SerbanHindmarsh:2005">2005</a>)</span>. An ODE system is
specified exactly the same way with a function of exactly the same
signature. The only difference is in the call to the integrator for
the solution; the <code>rk45</code> suffix is replaced with <code>bdf</code>, as in</p>
<pre><code>y_hat = integrate_ode_bdf(sho, y0, t0, ts, theta, x_r, x_i);</code></pre>
<p>Using the stiff (<code>bdf</code>) integrator on a system that is not stiff
may be much slower than using the non-stiff (<code>rk45</code>) integrator;
this is because it computes additional Jacobians to guide the
integrator. On the other hand, attempting to use the non-stiff
integrator for a stiff system will fail due to requiring a small step
size and too many steps.</p>
</div>
<div id="control-parameters-for-ode-solving" class="section level2">
<h2><span class="header-section-number">18.6</span> Control Parameters for ODE Solving</h2>
<p>The calls to the integrators shown above just used the default
control settings. Both the non-stiff and stiff integrators allow
three additional arguments, all of which must be supplied if any of
them is required.</p>
<pre><code>y_hat = integrate_ode_bdf(sho, y0, t0, ts, theta, x_r, x_i,
                          rel_tol, abs_tol, max_steps);</code></pre>
<p>The three control arguments are relative tolerance, absolute
tolerance, and maximum number of steps. The default values for
relative and absolute tolerance are both <code>1e-6</code> (<span class="math inline">\(10^{-6}\)</span>), and
the default maximum number of steps is <code>1e6</code> (<span class="math inline">\(10^6\)</span>).</p>
<div id="data-only-for-control-parameters" class="section level3 unnumbered">
<h3>Data only for control parameters</h3>
<p>The control parameters must be data variables—they can not be
parameters or expressions that depend on parameters, including local
variables in any block other than transformed data and generated
quantities. User-defined function arguments may be qualified as only
allowing data arguments using the <code>data</code> qualifier.</p>
</div>
<div id="tolerance-1" class="section level3 unnumbered">
<h3>Tolerance</h3>
<p>The relative and absolute tolerance control the accuracy of the
solutions generated by the integrator. Relative tolerances are
relative to the solution value, whereas absolute tolerances is the
maximum absolute error allowed in a solution.</p>
<p>Smaller tolerances produce more accurate solutions. Smaller
tolerances also require more computation time.</p>
<div id="sensitivity-analysis-1" class="section level4 unnumbered">
<h4>Sensitivity Analysis</h4>
<p>The tolerances should be set low enough that setting them lower does
not change the statistical properties of posterior samples generated
by the Stan program.</p>
</div>
</div>
<div id="maximum-number-of-steps-1" class="section level3 unnumbered">
<h3>Maximum Number of Steps</h3>
<p>The maximum number of steps can be used to stop a runaway simulation.
This can arise in MCMC when a bad jump is taken, particularly during
warmup. With the non-stiff solver, this may result in jumping into a
stiff region of the parameter space, which would require a small
step size and many steps to satisfy even modest tolerances.</p>

</div>
</div>
</div>
<h3><i style="font-size: 110%; color:#990017;">References</i></h3>
<div id="refs" class="references">
<div id="ref-DormandPrince:1980">
<p>Dormand, John R, and Peter J Prince. 1980. “A Family of Embedded Runge-Kutta Formulae.” <em>Journal of Computational and Applied Mathematics</em> 6 (1): 19–26.</p>
</div>
<div id="ref-AhnertMulansky:2011">
<p>Ahnert, Karsten, and Mario Mulansky. 2011. “Odeint—Solving Ordinary Differential Equations in C++.” <em>arXiv</em> 1110.3397.</p>
</div>
<div id="ref-CohenHindmarsh:1996">
<p>Cohen, Scott D, and Alan C Hindmarsh. 1996. “CVODE, a Stiff/Nonstiff ODE Solver in C.” <em>Computers in Physics</em> 10 (2): 138–43.</p>
</div>
<div id="ref-SerbanHindmarsh:2005">
<p>Serban, Radu, and Alan C Hindmarsh. 2005. “CVODES: The Sensitivity-Enabled ODE Solver in SUNDIALS.” In <em>ASME 2005 International Design Engineering Technical Conferences and Computers and Information in Engineering Conference</em>, 257–69. American Society of Mechanical Engineers.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="27">
<li id="fn27"><p>This example is drawn from the documentation for the Boost Numeric Odeint library <span class="citation">(Ahnert and Mulansky <a href="#ref-AhnertMulansky:2011">2011</a>)</span>, which Stan uses to implement the <code>rk45</code> solver.<a href="ode-solver-chapter.html#fnref27" class="footnote-back">↩</a></p></li>
<li id="fn28"><p>Not coincidentally, high curvature in the posterior of a general Stan model poses the same kind of problem for Euclidean Hamiltonian Monte Carlo (HMC) sampling. The reason is that HMC is based on the leapfrog algorithm, a gradient-based, stepwise numerical differential equation solver specialized for Hamiltonian systems with separable potential and kinetic energy terms.<a href="ode-solver-chapter.html#fnref28" class="footnote-back">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="algebra-solver-chapter.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="part-3-programming-techniques.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": null,
"fontsettings": {
"theme": "white",
"family": "serif",
"size": 2
},
"edit": null,
"download": null,
"toc": {
"collapse": "section",
"scroll_highlight": true
},
"search": true,
"toolbar": {
"position": "static"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
