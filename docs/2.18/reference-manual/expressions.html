<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Stan Reference Manual</title>
  <meta name="description" content="Stan reference manual specifying the syntax and semantics of the Stan programming language.">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="Stan Reference Manual" />
  <meta property="og:type" content="book" />
  
  <meta property="og:image" content="img/logo_tm.png" />
  <meta property="og:description" content="Stan reference manual specifying the syntax and semantics of the Stan programming language." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Stan Reference Manual" />
  
  <meta name="twitter:description" content="Stan reference manual specifying the syntax and semantics of the Stan programming language." />
  <meta name="twitter:image" content="img/logo_tm.png" />

<meta name="author" content="Stan Development Team">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="data-types-chapter.html">
<link rel="next" href="statements.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />










<link rel="stylesheet" href="../stan-manual.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li style="font-size:110%; font-weight:400; font-family: Verdana, Helvetica, sans; line-height:1.4; margin: 0.5em 0 0 1em">Stan Reference Manual</li>

<li class="divider"></li>
<li><a href="index.html#overview"><i style="font-size: 110%; padding:1.5em 0 0 0; color:#990017;">Overview</i></a></li>
<li><a href="language.html#language"><i style="font-size: 110%; color:#990017;">Language</i></a></li>
<li class="chapter" data-level="1" data-path="character-encoding.html"><a href="character-encoding.html"><i class="fa fa-check"></i><b>1</b> Character Encoding</a></li>
<li class="chapter" data-level="2" data-path="includes-section.html"><a href="includes-section.html"><i class="fa fa-check"></i><b>2</b> Includes</a></li>
<li class="chapter" data-level="3" data-path="comments-section.html"><a href="comments-section.html"><i class="fa fa-check"></i><b>3</b> Comments</a></li>
<li class="chapter" data-level="4" data-path="whitespace.html"><a href="whitespace.html"><i class="fa fa-check"></i><b>4</b> Whitespace</a></li>
<li class="chapter" data-level="5" data-path="data-types-chapter.html"><a href="data-types-chapter.html"><i class="fa fa-check"></i><b>5</b> Data Types and Declarations</a></li>
<li class="chapter" data-level="6" data-path="expressions.html"><a href="expressions.html"><i class="fa fa-check"></i><b>6</b> Expressions</a></li>
<li class="chapter" data-level="7" data-path="statements.html"><a href="statements.html"><i class="fa fa-check"></i><b>7</b> Statements</a></li>
<li class="chapter" data-level="8" data-path="blocks-chapter.html"><a href="blocks-chapter.html"><i class="fa fa-check"></i><b>8</b> Program Blocks</a></li>
<li class="chapter" data-level="9" data-path="functions-chapter.html"><a href="functions-chapter.html"><i class="fa fa-check"></i><b>9</b> User-Defined Functions</a></li>
<li class="chapter" data-level="10" data-path="variable-transforms-chapter.html"><a href="variable-transforms-chapter.html"><i class="fa fa-check"></i><b>10</b> Constraint Transforms</a></li>
<li class="chapter" data-level="11" data-path="language-syntax.html"><a href="language-syntax.html"><i class="fa fa-check"></i><b>11</b> Language Syntax</a></li>
<li class="chapter" data-level="12" data-path="program-execution.html"><a href="program-execution.html"><i class="fa fa-check"></i><b>12</b> Program Execution</a></li>
<li class="chapter" data-level="13" data-path="deprecated-features-appendix.html"><a href="deprecated-features-appendix.html"><i class="fa fa-check"></i><b>13</b> Deprecated Features</a></li>
<li><a href="algorithms.html#algorithms"><i style="font-size: 110%; color:#990017;">Algorithms</i></a></li>
<li class="chapter" data-level="14" data-path="hmc-chapter.html"><a href="hmc-chapter.html"><i class="fa fa-check"></i><b>14</b> MCMC Sampling</a></li>
<li class="chapter" data-level="15" data-path="analysis-chapter.html"><a href="analysis-chapter.html"><i class="fa fa-check"></i><b>15</b> Posterior Analysis</a></li>
<li class="chapter" data-level="16" data-path="optimization-algorithms-chapter.html"><a href="optimization-algorithms-chapter.html"><i class="fa fa-check"></i><b>16</b> Optimization</a></li>
<li class="chapter" data-level="17" data-path="vi-algorithms-chapter.html"><a href="vi-algorithms-chapter.html"><i class="fa fa-check"></i><b>17</b> Variational Inference</a></li>
<li class="chapter" data-level="18" data-path="diagnostic-algorithms-chapter.html"><a href="diagnostic-algorithms-chapter.html"><i class="fa fa-check"></i><b>18</b> Diagnostic Mode</a></li>
<li><a href="usage.html#usage"><i style="font-size: 110%; color:#990017;">Usage</i></a></li>
<li class="chapter" data-level="19" data-path="reproducibility-chapter.html"><a href="reproducibility-chapter.html"><i class="fa fa-check"></i><b>19</b> Reproducibility</a></li>
<li class="chapter" data-level="20" data-path="licensing-appendix.html"><a href="licensing-appendix.html"><i class="fa fa-check"></i><b>20</b> Licenses and Dependencies</a></li>
<li><a href="references.html#references"><i style="font-size: 110%; color:#990017;">References</i></a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Stan Reference Manual</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="expressions" class="section level1">
<h1><span class="header-section-number">6</span> Expressions</h1>
<p>An expression is the syntactic unit in a Stan program that denotes a
value. Every expression in a well-formed Stan program has a type that
is determined statically (at compile time), based only on the type of
its variables and the types of the functions used in it. If an
expressions type cannot be determined statically, the Stan compiler
will report the location of the problem.</p>
<p>This chapter covers the syntax, typing, and usage of the various forms
of expressions in Stan.</p>
<div id="numeric-literals" class="section level2">
<h2><span class="header-section-number">6.1</span> Numeric Literals</h2>
<p>The simplest form of expression is a literal that denotes a primitive
numerical value.</p>
<div id="integer-literals" class="section level3 unnumbered">
<h3>Integer Literals</h3>
<p>Integer literals represent integers of type <code>int</code>. Integer
literals are written in base 10 without any separators. Integer
literals may contain a single negative sign. (The expression
<code>--1</code> is interpreted as the negation of the literal <code>-1</code>.)</p>
<p>The following list contains well-formed integer literals.</p>
<pre><code>0, 1, -1, 256, -127098, 24567898765</code></pre>
<p>Integer literals must have values that fall within the bounds for
integer values (see <a href="data-types-chapter.html#numerical-data-types.section">section</a>).</p>
<p>Integer literals may not contain decimal points (<code>.</code>). Thus the
expressions <code>1.</code> and <code>1.0</code> are of type <code>real</code> and may
not be used where a value of type <code>int</code> is required.</p>
</div>
<div id="real-literals" class="section level3 unnumbered">
<h3>Real Literals</h3>
<p>A number written with a period or with scientific notation is assigned
to a the continuous numeric type <code>real</code>. Real literals are
written in base 10 with a period (<code>.</code>) as a separator and
optionally an exponent with optional sign. Examples
of well-formed real literals include the following.</p>
<pre><code>0.0, 1.0, 3.14, -217.9387, 2.7e3, -2E-5, 1.23e+3.</code></pre>
<p>The notation <code>e</code> or <code>E</code> followed by a positive or negative
integer denotes a power of 10 to multiply. For instance, <code>2.7e3</code>
and <code>2.7e+3</code> denote <span class="math inline">\(2.7 \times 10^3\)</span>, whereas <code>-2E-5</code> denotes <span class="math inline">\(-2 \times 10^{-5}\)</span>.</p>
</div>
</div>
<div id="variables.section" class="section level2">
<h2><span class="header-section-number">6.2</span> Variables</h2>
<p>A variable by itself is a well-formed expression of the same type as
the variable. Variables in Stan consist of ASCII strings containing
only the basic lower-case and upper-case Roman letters, digits, and
the underscore (<code>_</code>) character. Variables must start with a
letter (<code>a--z</code> and <code>A--Z</code>) and may not end with two underscores
(<code>__</code>).</p>
<p>Examples of legal variable identifiers are as follows.</p>
<pre><code>a, a3, a_3, Sigma, my_cpp_style_variable, myCamelCaseVariable</code></pre>
<p>Unlike in R and BUGS, variable identifiers in Stan may not contain
a period character.</p>
<div id="reserved-names" class="section level3 unnumbered">
<h3>Reserved Names</h3>
<p>Stan reserves many strings for internal use and these may not be used
as the name of a variable. An attempt to name a variable after an
internal string results in the <code>stanc</code> translator halting with an
error message indicating which reserved name was used and its location
in the model code.</p>
<div id="model-name" class="section level4 unnumbered">
<h4>Model Name</h4>
<p>The name of the model cannot be used as a variable within the model.
This is usually not a problem because the default in <code>bin/stanc</code>
is to append <code>_model</code> to the name of the file containing the
model specification. For example, if the model is in file
<code>foo.stan</code>, it would not be legal to have a variable named
<code>foo_model</code> when using the default model name through
<code>bin/stanc</code>. With user-specified model names, variables cannot
match the model.</p>
</div>
<div id="user-defined-function-names" class="section level4 unnumbered">
<h4>User-Defined Function Names</h4>
<p>User-defined function names cannot be used as a variable within the
model.</p>
</div>
<div id="reserved-words-from-stan-language" class="section level4 unnumbered">
<h4>Reserved Words from Stan Language</h4>
<p>The following list contains reserved words for Stan’s programming
language. Not all of these features are implemented in Stan yet, but
the tokens are reserved for future use.</p>
<pre><code>for, in, while, repeat, until, if, then, else,
true, false, target</code></pre>
<p>Variables should not be named after types, either, and thus may not be
any of the following.</p>
<pre><code>int, real, vector, simplex, unit_vector, ordered,
positive_ordered, row_vector, matrix,
cholesky_factor_corr, cholesky_factor_cov,
corr_matrix, cov_matrix.</code></pre>
<p>Variable names will <em>not</em> conflict with the following block identifiers,</p>
<pre><code>functions, model, data, parameters, quantities,
transformed, generated</code></pre>
</div>
<div id="reserved-names-from-stan-implementation" class="section level4 unnumbered">
<h4>Reserved Names from Stan Implementation</h4>
<p>Some variable names are reserved because they are used within
Stan’s C++ implementation. These are</p>
<pre><code>var, fvar, STAN_MAJOR, STAN_MINOR, STAN_PATCH,
STAN_MATH_MAJOR, STAN_MATH_MINOR, STAN_MATH_PATCH</code></pre>
</div>
<div id="reserved-function-and-distribution-names" class="section level4 unnumbered">
<h4>Reserved Function and Distribution Names</h4>
<p>Variable names will conflict with the names of predefined functions
other than constants. Thus a variable may not be named <code>logit</code>
or <code>add</code>, but it may be named <code>pi</code> or <code>e</code>.</p>
<p>Variable names will also conflict with the names of distributions
suffixed with <code>_lpdf</code>, <code>_lpmf</code>, <code>_lcdf</code>, and <code>_lccdf</code>, <code>_cdf</code>, and
<code>_ccdf</code>, such as <code>normal_lcdf_log</code>; this also holds for the deprecated
forms <code>_log</code>, <code>_cdf_log</code>, and <code>_ccdf_log</code>,</p>
<p>Using any of these variable names causes the <code>stanc</code> translator
to halt and report the name and location of the variable causing the
conflict.</p>
</div>
<div id="reserved-names-from-c" class="section level4 unnumbered">
<h4>Reserved Names from C++</h4>
<p>Finally, variable names, including the names of models, should not
conflict with any of the C++ keywords.</p>
<pre><code>alignas, alignof, and, and_eq, asm, auto, bitand, bitor, bool,
break, case, catch, char, char16_t, char32_t, class, compl,
const, constexpr, const_cast, continue, decltype, default,
delete, do, double, dynamic_cast, else, enum, explicit,
export, extern, false, float, for, friend, goto, if,
inline, int, long, mutable, namespace, new, noexcept,
not, not_eq, nullptr, operator, or, or_eq, private,
protected, public, register, reinterpret_cast, return,
short, signed, sizeof, static, static_assert, static_cast,
struct, switch, template, this, thread_local, throw, true,
try, typedef, typeid, typename, union, unsigned, using,
virtual, void, volatile, wchar_t, while, xor, xor_eq</code></pre>
</div>
</div>
<div id="legal-characters" class="section level3 unnumbered">
<h3>Legal Characters</h3>
<p>The legal characters for variable identifiers are given in the
<a href="#identifier-characters-table">identifier characters table</a>.</p>
<p><strong>Identifier Characters Table.</strong> id:identifier-characters-table
<em>The alpanumeric characters and underscore in base ASCII are the only
legal characters in Stan identifiers.</em></p>
<table>
<thead>
<tr class="header">
<th align="center">characters</th>
<th align="center">ASCII code points</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>a -- z</code></td>
<td align="center">97 – 122</td>
</tr>
<tr class="even">
<td align="center"><code>A -- Z</code></td>
<td align="center">65 – 90</td>
</tr>
<tr class="odd">
<td align="center"><code>0 -- 9</code></td>
<td align="center">48 – 57</td>
</tr>
<tr class="even">
<td align="center"><code>_</code></td>
<td align="center">95</td>
</tr>
</tbody>
</table>
<p>Although not the most expressive character set, ASCII is the most
portable and least prone to corruption through improper character
encodings or decodings. Sticking to this range of ASCII makes Stan
compatible with Latin-1 or UTF-8 encodings of these characters, which
are byte-for-byte identical to ASCII.</p>
<div id="comments-allow-ascii-compatible-encoding" class="section level4 unnumbered">
<h4>Comments Allow ASCII-Compatible Encoding</h4>
<p>Within comments, Stan can work with any ASCII-compatible character
encoding, such as ASCII itself, UTF-8, or Latin1. It is up to user
shells and editors to display them properly.</p>
</div>
</div>
</div>
<div id="vector-matrix-and-array-expressions" class="section level2">
<h2><span class="header-section-number">6.3</span> Vector, Matrix, and Array Expressions</h2>
<p>Expressions for the Stan container objects arrays, vectors, and
matrices can be constructed via a sequence of expressions
enclosed in either curly braces for arrays, or square brackets for
vectors and matrices.</p>
<div id="vector-expressions" class="section level3 unnumbered">
<h3>Vector Expressions</h3>
<p>Square brackets may be wrapped around a sequence of comma separated
primitive expressions to produce a row vector expression. For
example, the expression <code>[ 1, 10, 100 ]</code> denotes a row vector of
three elements with real values 1.0, 10.0, and 100.0.
Applying the transpose operator to a row vector expression produces
a vector expression.
This syntax provides a way declare and define small vectors a single line, as follows.</p>
<pre class="stan"><code>row_vector[2] rv2=  [ 1, 2 ];
vector[3] v3 = [ 3, 4, 5 ]&#39;;</code></pre>
<p>The vector expression values may be compound expressions
or variable names, so it is legal to write
<code>[ 2 * 3, 1 + 4]</code> or <code>[ x, y ]</code>, providing that <code>x</code>
and <code>y</code> are primitive variables.</p>
</div>
<div id="matrix-expressions" class="section level3 unnumbered">
<h3>Matrix Expressions</h3>
<p>A matrix expression consists of square brackets wrapped
around a sequence of comma separated row vector expressions.
This syntax provides a way declare and define a matrix in a single
line, as follows.</p>
<pre class="stan"><code>matrix[3,2] m1 = [ [ 1, 2 ], [ 3, 4 ], [5, 6 ] ];</code></pre>
<p>Any expression denoting a row vector can be used in a matrix expression.
For example, the following code is valid:</p>
<pre class="stan"><code>vector[2] vX = [ 1, 10 ]&#39;;
row_vector[2] vY = [ 100, 1000 ];
matrix[3,2] m2 = [ vX&#39;, vY, [ 1, 2 ]  ];</code></pre>
<div id="no-empty-vector-or-matrix-expressions" class="section level4 unnumbered">
<h4>No empty vector or matrix expressions</h4>
<p>The empty expression <code>[ ]</code> is ambiguous and therefore is not
allowed and similarly expressions such as <code>[ [ ] ]</code> or
<code>[ [ ], [ ] ]</code> are not allowed.</p>
</div>
</div>
<div id="array-expressions" class="section level3 unnumbered">
<h3>Array Expressions</h3>
<p>Curly braces may be wrapped around a sequence of expressions to
produce an array expression. For example, the expression
<code>{ 1, 10, 100 }</code> denotes an integer array of three elements with
values 1, 10, and 100. This syntax is particularly convenient to
define small arrays in a single line, as follows.</p>
<pre class="stan"><code>int a[3] = { 1, 10, 100 };</code></pre>
<p>The values may be compound expressions, so it is legal to write
<code>{ 2 * 3, 1 + 4 }</code>. It is also possible to write two dimensional
arrays directly, as in the following example.</p>
<pre class="stan"><code>int b[2, 3] = { { 1, 2, 3 }, { 4, 5, 6 } };</code></pre>
<p>This way, <code>b[1]</code> is <code>{ 1, 2, 3 }</code> and <code>b[2]</code> is
<code>{ 4, 5, 6 }</code>.</p>
<p>Whitespace is always interchangeable in Stan, so the above can be laid
out as follows to more clearly indicate the row and column structure
of the resulting two dimensional array.</p>
<pre class="stan"><code>int b[2, 3] = { { 1, 2, 3 },
                { 4, 5, 6 } };</code></pre>
</div>
<div id="array-expression-types" class="section level3 unnumbered">
<h3>Array Expression Types</h3>
<p>Any type of expression may be used within braces to form an array
expression. In the simplest case, all of the elements will be of the
same type and the result will be an array of elements of that type.
For example, the elements of the array can be vectors, in which case
the result is an array of vectors.</p>
<pre class="stan"><code>vector[3] b;
vector[3] c;
...
vector[3] d[2] = { b, c };</code></pre>
<p>The elements may also be a mixture of <code>int</code> and <code>real</code> typed
expressions, in which case the result is an array of real values.</p>
<pre class="stan"><code>real b[2] = { 1, 1.9 };</code></pre>
</div>
<div id="restrictions-on-values" class="section level3 unnumbered">
<h3>Restrictions on Values</h3>
<p>There are some restrictions on how array expressions may be used that
arise from their types being calculated bottom up and the basic data
type and assignment rules of Stan.</p>
<div id="rectangular-array-expressions-only" class="section level4 unnumbered">
<h4>Rectangular array expressions only</h4>
<p>Although it is tempting to try to define a ragged array expression,
all Stan data types are rectangular (or boxes or other
higher-dimensional generalizations). Thus the following nested array
expression will cause an error when it tries to create a
non-rectangular array.</p>
<pre class="stan"><code>{ { 1, 2, 3 }, { 4, 5 } }  // compile time error: size mismatch</code></pre>
<p>This may appear to be OK, because it is creating a two-dimensional
integer array (<code>int[ , ]</code>) out of two one-dimensional array
integer arrays (<code>int[ ]</code>). But it is not allowed because the two
one-dimensional arrays are not the same size. If the elements are
array expressions, this can be diagnosed at compile time. If one or
both expressions is a variable, then that won’t be caught until
runtime.</p>
<pre class="stan"><code>{ { 1, 2, 3 }, m }  // runtime error if m not size 3</code></pre>
</div>
<div id="no-empty-array-expressions" class="section level4 unnumbered">
<h4>No empty array expressions</h4>
<p>Because there is no way to infer the type of the result, the empty
array expression (<code>{ }</code>) is not allowed. This does not sacrifice
expressive power, because a declaration is sufficient to initialize a
zero-element array.</p>
<pre class="stan"><code>int a[0];   // a is fully defined as zero element array</code></pre>
</div>
<div id="integer-only-array-expressions" class="section level4 unnumbered">
<h4>Integer only array expressions</h4>
<p>If an array expression contains only integer elements, such as
<code>{ 1, 2, 3 }</code>, then the result type will be an integer array,
<code>int[]</code>. This means that the following will <em>not</em> be
legal.</p>
<pre class="stan"><code>real a[2] = { -3, 12 };  // error: int[] can&#39;t be assigned to real[]</code></pre>
<p>Integer arrays may not be assigned to real values. However, this
problem is easily sidestepped by using real literal expressions.</p>
<pre class="stan"><code>real a[2] = { -3.0, 12.0 };</code></pre>
<p>Now the types match and the assignment is allowed.</p>
</div>
</div>
</div>
<div id="parentheses-for-grouping" class="section level2">
<h2><span class="header-section-number">6.4</span> Parentheses for Grouping</h2>
<p>Any expression wrapped in parentheses is also an expression. Like in
C++, but unlike in R, only the round parentheses, <code>(</code> and
<code>)</code>, are allowed. The square brackets <code>[</code> and <code>]</code> are
reserved for array indexing and the curly braces <code>{</code> and
<code>}</code> for grouping statements.</p>
<p>With parentheses it is possible to explicitly group subexpressions
with operators. Without parentheses, the expression <code>1 + 2 * 3</code>
has a subexpression <code>2 * 3</code> and evaluates to 7. With
parentheses, this grouping may be made explicit with the expression
<code>1 + (2 * 3)</code>. More importantly, the expression <code>(1 + 2) *   3</code> has <code>1 + 2</code> as a subexpression and evaluates to 9.</p>
</div>
<div id="arithmetic-expressions.section" class="section level2">
<h2><span class="header-section-number">6.5</span> Arithmetic and Matrix Operations on Expressions</h2>
<p>For integer and real-valued expressions, Stan supports the basic
binary arithmetic operations of addition (<code>+</code>), subtraction
(<code>-</code>), multiplication (<code>*</code>) and division (<code>/</code>) in the
usual ways.</p>
<p>For integer expressions, Stan supports the modulus (<code>%</code>) binary
arithmetic operation. Stan also supports the unary operation of
negation for integer and real-valued expressions. For example,
assuming <code>n</code> and <code>m</code> are integer variables and <code>x</code> and
<code>y</code> real variables, the following expressions are legal.</p>
<pre><code>3.0 + 0.14
-15
2 * 3 + 1
(x - y) / 2.0
(n * (n + 1)) / 2
x / n
m % n</code></pre>
<p>The negation, addition, subtraction, and multiplication operations are
extended to matrices, vectors, and row vectors. The transpose
operation, written using an apostrophe (<code>'</code>) is also supported
for vectors, row vectors, and matrices. Return types for matrix
operations are the smallest types that can be statically guaranteed to
contain the result. The full set of allowable input types and
corresponding return types is detailed in the list of functions.</p>
<p>For example, if <code>y</code> and <code>mu</code> are variables of type <code>vector</code> and
<code>Sigma</code> is a variable of type <code>matrix</code>, then <code>(y - mu)' * Sigma * (y - mu)</code> is a well-formed expression of type <code>real</code>. The type of the
complete expression is inferred working outward from the
subexpressions. The subexpression(s) <code>y - mu</code> are of type <code>vector</code>
because the variables <code>y</code> and <code>mu</code> are of type <code>vector</code>. The
transpose of this expression, the subexpression <code>(y - mu)'</code> is of type
<code>row_vector</code>. Multiplication is left associative and transpose has
higher precedence than multiplication, so the above expression is
equivalent to the following fully specified form <code>(((y - mu)') * Sigma) * (y - mu)</code>.</p>
<p>The type of subexpression <code>(y - mu)' * Sigma</code> is inferred to be
<code>row_vector</code>, being the result of multiplying a row vector by a
matrix. The whole expression’s type is thus the type of a row vector
multiplied by a (column) vector, which produces a <code>real</code> value.</p>
<p>Stan provides elementwise matrix multiplication (e.g., <code>a .* b</code>) and
division (e.g., <code>a ./ b</code>) operations. These provide a shorthand to
replace loops, but are not intrinsically more efficient than a version
programmed with an elementwise calculations and assignments in a loop.
For example, given declarations,</p>
<pre class="stan"><code>vector[N] a;
vector[N] b;
vector[N] c;</code></pre>
<p>the assignment,</p>
<pre class="stan"><code>c = a .* b;</code></pre>
<p>produces the same result with roughly the same efficiency as the loop</p>
<pre class="stan"><code>for (n in 1:N)
  c[n] = a[n] * b[n];</code></pre>
<p>Stan supports exponentiation (<code>^</code>) of integer and
real-valued expressions. The return type of exponentiation is always
a real-value. For example, assuming <code>n</code> and <code>m</code> are integer
variables and <code>x</code> and <code>y</code> real variables, the following
expressions are legal.</p>
<pre><code>3 ^ 2
3.0 ^ -2
3.0 ^ 0.14
x ^ n
n ^ x
n ^ m
x ^ y</code></pre>
<p>Exponentiation is right associative, so the expression <code>2 ^ 3 ^ 4</code>
is equivalent to the fully specified form <code>2 ^ (3 ^ 4)</code>.</p>
<div id="operator-precedence-and-associativity" class="section level3 unnumbered">
<h3>Operator Precedence and Associativity</h3>
<p>The precedence and associativity of operators, as well as built-in
syntax such as array indexing and function application is given in
tabular form in the <a href="expressions.html#operator-precedence-table">operator precedence table</a>.</p>
<p><strong>Operator Precedence Table.</strong> <a id="operator-precedence-table"></a>
<em>Stan’s unary, binary, and ternary
operators, with their precedences, associativities, place in an
expression, and a description. The last two lines list the precedence
of function application and array, matrix, and vector indexing. The
operators are listed in order of precedence, from least tightly
binding to most tightly binding. The full set of legal arguments and
corresponding result types are provided in the function documentation
for the operators (i.e.,</em> <code>operator*(int,int):int</code> <em>indicates the
application of the multiplication operator to two integers, which
returns an integer). Parentheses may be used to group expressions
explicitly rather than relying on precedence and
associativity.</em></p>
<table>
<thead>
<tr class="header">
<th align="center">Op.</th>
<th align="right">Prec.</th>
<th align="center">Assoc.</th>
<th align="left">Placement</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>? ~ :</code></td>
<td align="right">10</td>
<td align="center">right</td>
<td align="left">ternary infix</td>
<td align="left">conditional</td>
</tr>
<tr class="even">
<td align="center"><code>||</code></td>
<td align="right">9</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">logical or</td>
</tr>
<tr class="odd">
<td align="center"><code>&amp;&amp;</code></td>
<td align="right">8</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">logical and</td>
</tr>
<tr class="even">
<td align="center"><code>==</code></td>
<td align="right">7</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">equality</td>
</tr>
<tr class="odd">
<td align="center"><code>!=</code></td>
<td align="right">7</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">inequality</td>
</tr>
<tr class="even">
<td align="center"><code>&lt;</code></td>
<td align="right">6</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">less than</td>
</tr>
<tr class="odd">
<td align="center"><code>&lt;=</code></td>
<td align="right">6</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">less than or equal</td>
</tr>
<tr class="even">
<td align="center"><code>&gt;</code></td>
<td align="right">6</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">greater than</td>
</tr>
<tr class="odd">
<td align="center"><code>&gt;=</code></td>
<td align="right">6</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">greater than or equal</td>
</tr>
<tr class="even">
<td align="center"><code>+</code></td>
<td align="right">5</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">addition</td>
</tr>
<tr class="odd">
<td align="center"><code>-</code></td>
<td align="right">5</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">subtraction</td>
</tr>
<tr class="even">
<td align="center"><code>*</code></td>
<td align="right">4</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">multiplication</td>
</tr>
<tr class="odd">
<td align="center"><code>/</code></td>
<td align="right">4</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">(right) division</td>
</tr>
<tr class="even">
<td align="center"><code>%</code></td>
<td align="right">4</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">modulus</td>
</tr>
<tr class="odd">
<td align="center"><code>\</code></td>
<td align="right">3</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">left division</td>
</tr>
<tr class="even">
<td align="center"><code>.*</code></td>
<td align="right">2</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">elementwise multiplication</td>
</tr>
<tr class="odd">
<td align="center"><code>./</code></td>
<td align="right">2</td>
<td align="center">left</td>
<td align="left">binary infix</td>
<td align="left">elementwise division</td>
</tr>
<tr class="even">
<td align="center"><code>!</code></td>
<td align="right">1</td>
<td align="center">n/a</td>
<td align="left">unary prefix</td>
<td align="left">logical negation</td>
</tr>
<tr class="odd">
<td align="center"><code>-</code></td>
<td align="right">1</td>
<td align="center">n/a</td>
<td align="left">unary prefix</td>
<td align="left">negation</td>
</tr>
<tr class="even">
<td align="center"><code>+</code></td>
<td align="right">1</td>
<td align="center">n/a</td>
<td align="left">unary prefix</td>
<td align="left">promotion (no-op in Stan)</td>
</tr>
<tr class="odd">
<td align="center"><code>^</code></td>
<td align="right">0.5</td>
<td align="center">right</td>
<td align="left">binary infix</td>
<td align="left">exponentiation</td>
</tr>
<tr class="even">
<td align="center"><code>'</code></td>
<td align="right">0</td>
<td align="center">n/a</td>
<td align="left">unary postfix</td>
<td align="left">transposition</td>
</tr>
<tr class="odd">
<td align="center"><code>()</code></td>
<td align="right">0</td>
<td align="center">n/a</td>
<td align="left">prefix, wrap</td>
<td align="left">function application</td>
</tr>
<tr class="even">
<td align="center"><code>[]</code></td>
<td align="right">0</td>
<td align="center">left</td>
<td align="left">prefix, wrap</td>
<td align="left">array, matrix indexing</td>
</tr>
</tbody>
</table>
<p>Other expression-forming operations, such as function application and
subscripting bind more tightly than any of the arithmetic operations.</p>
<p>The precedence and associativity determine how expressions are
interpreted. Because addition is left associative, the expression
<code>a + b + c</code> is interpreted as <code>(a + b) + c</code>. Similarly,
<code>a / b * c</code> is interpreted as <code>(a / b) * c</code>.</p>
<p>Because multiplication has higher precedence than addition, the
expression <code>a * b + c</code> is interpreted as <code>(a * b) + c</code> and the
expression <code>a + b * c</code> is interpreted as <code>a + (b * c)</code>. Similarly,
<code>2 * x + 3 * - y</code> is interpreted as <code>(2 * x) + (3 * (-y))</code>.</p>
<p>Transposition and exponentiation bind more tightly
than any other arithmetic or logical operation.
For vectors, row vectors, and matrices,
<code>-u'</code> is interpreted as <code>-(u')</code>, <code>u * v'</code> as
<code>u* (v')</code>, and <code>u' * v</code> as <code>(u') * v</code>.
For integer and reals, <code>-n ^ 3</code> is interpreted as <code>-(n ^ 3)</code>.</p>
</div>
</div>
<div id="conditional-operator.section" class="section level2">
<h2><span class="header-section-number">6.6</span> Conditional Operator</h2>
<div id="conditional-operator-syntax" class="section level3 unnumbered">
<h3>Conditional Operator Syntax</h3>
<p>The ternary conditional operator is unique in that it takes three
arguments and uses a mixed syntax. If <code>a</code> is an expression of
type <code>int</code> and <code>b</code> and <code>c</code> are expressions that can be
converted to one another (e.g., compared with <code>==</code>), then</p>
<pre class="stan"><code>a ? b : c</code></pre>
<p>is an expression of the promoted type of <code>b</code> and <code>c</code>. The
only promotion allowed in Stan is from integer to real; if one
argument is of type <code>int</code> and the other of type <code>real</code>, the
conditional expression as a whole is of type <code>real</code>. In all
other cases, the arguments have to be of the same underlying Stan type
(i.e., constraints don’t count, only the shape) and the conditional
expression is of that type.</p>
<div id="conditional-operator-precedence" class="section level4 unnumbered">
<h4>Conditional Operator Precedence</h4>
<p>The conditional operator is the most loosely binding operator, so its
arguments rarely require parentheses for disambiguation. For example,</p>
<pre class="stan"><code>a &gt; 0 || b &lt; 0 ? c + d : e - f</code></pre>
<p>is equivalent to the explicitly grouped version</p>
<pre class="stan"><code>(a &gt; 0 || b &lt; 0) ? (c + d) : (e - f)</code></pre>
<p>The latter is easier to read even if the parentheses are not strictly
necessary.</p>
</div>
<div id="conditional-operator-associativity" class="section level4 unnumbered">
<h4>Conditional Operator Associativity</h4>
<p>The conditional operator is right associative, so that</p>
<pre class="stan"><code>a ? b : c ? d : e</code></pre>
<p>parses as if explicitly grouped as</p>
<pre class="stan"><code>a ? b : (c ? d : e)</code></pre>
<p>Again, the explicitly grouped version is easier to read.</p>
</div>
</div>
<div id="conditional-operator-semantics" class="section level3 unnumbered">
<h3>Conditional Operator Semantics</h3>
<p>Stan’s conditional operator works very much like its C++ analogue.
The first argument must be an expression denoting an integer.
Typically this is a variable or a relation operator, as in the
variable <code>a</code> in the example above. Then there are two resulting
arguments, the first being the result returned if the condition
evaluates to true (i.e., non-zero) and the second if the condition
evaluates to false (i.e., zero). In the example above, the value
<code>b</code> is returned if the condition evaluates to a non-zero value
and <code>c</code> is returned if the condition evaluates to zero.</p>
<div id="lazy-evaluation-of-results" class="section level4 unnumbered">
<h4>Lazy Evaluation of Results</h4>
<p>The key property of the conditional operator that makes it so useful
in high-performance computing is that it only evaluates the returned
subexpression, not the alternative expression. In other words, it is
not like a typical function that evaluates its argument expressions
eagerly in order to pass their values to the function. As usual, the
saving is mostly in the derivatives that do not get computed rather
than the unnecessary function evaluation itself.</p>
</div>
<div id="promotion-to-parameter" class="section level4 unnumbered">
<h4>Promotion to Parameter</h4>
<p>If one return expression is a data value (an expression involving only
constants and variables defined in the data or transformed data
block), and the other is not, then the ternary operator will promote
the data value to a parameter value. This can cause needless work
calculating derivatives in some cases and be less efficient than a full
<code>if</code>-<code>then</code> conditional statement. For example,</p>
<pre class="stan"><code>data {
  real x[10];
  ...
parameters {
  real z[10];
  ...
model {
  y ~ normal(cond ? x : z, sigma);
  ...</code></pre>
<p>would be more efficiently (if not more transparently) coded as</p>
<pre class="stan"><code>if (cond)
  y ~ normal(x, sigma);
else
  y ~ normal(z, sigma);</code></pre>
<p>The conditional statement, like the conditional operator, only
evaluates one of the result statements. In this case, the variable
<code>x</code> will not be promoted to a parameter and thus not cause any
needless work to be carried out when propagating the chain rule during
derivative calculations.</p>
</div>
</div>
</div>
<div id="language-indexing.section" class="section level2">
<h2><span class="header-section-number">6.7</span> Indexing</h2>
<p>Stan arrays, matrices, vectors, and row vectors are all accessed
using the same array-like notation. For instance, if <code>x</code> is a
variable of type <code>real[]</code> (a one-dimensional array of reals)
then <code>x[1]</code> is the value of the first element of the
array.</p>
<p>Subscripting has higher precedence than any of the arithmetic
operations. For example, <code>alpha*x[1]</code> is equivalent to
<code>alpha*(x[1])</code>.</p>
<p>Multiple subscripts may be provided within a single pair of square
brackets. If <code>x</code> is of type <code>real[ , ]</code>, a two-dimensional
array, then <code>x[2,501]</code> is of type <code>real</code>.</p>
<div id="accessing-subarrays" class="section level3 unnumbered">
<h3>Accessing Subarrays</h3>
<p>The subscripting operator also returns subarrays of arrays. For
example, if <code>x</code> is of type <code>real[ , , ]</code>, then <code>x[2]</code>
is of type <code>real[ , ]</code>, and <code>x[2,3]</code> is of type
<code>real[]</code>. As a result, the expressions <code>x[2,3]</code> and
<code>x[2][3]</code> have the same meaning.</p>
</div>
<div id="accessing-matrix-rows" class="section level3 unnumbered">
<h3>Accessing Matrix Rows</h3>
<p>If <code>Sigma</code> is a variable of type <code>matrix</code>, then
<code>Sigma[1]</code> denotes the first row of <code>Sigma</code> and has the
type <code>row_vector</code>.</p>
</div>
<div id="mixing-array-and-vectormatrix-indexes" class="section level3 unnumbered">
<h3>Mixing Array and Vector/Matrix Indexes</h3>
<p>Stan supports mixed indexing of arrays and their vector, row vector
or matrix values. For example, if <code>m</code> is of type
<code>matrix[ , ]</code>, a two-dimensional array of matrices, then
<code>m[1]</code> refers to the first row of the array, which is a
one-dimensional array of matrices. More than one index may be used,
so that <code>m[1,2]</code> is of type <code>matrix</code> and denotes the matrix
in the first row and second column of the array. Continuing to add
indices, <code>m[1,2,3]</code> is of type <code>row_vector</code> and denotes
the third row of the matrix denoted by <code>m[1,2]</code>. Finally,
<code>m[1,2,3,4]</code> is of type <code>real</code> and denotes the value in the
third row and fourth column of the matrix that is found at the first
row and second column of the array <code>m</code>.</p>
</div>
</div>
<div id="language-multi-indexing.section" class="section level2">
<h2><span class="header-section-number">6.8</span> Multiple Indexing and Range Indexing</h2>
<p>In addition to single integer indexes, as described in
<a href="expressions.html#language-indexing.section">the language indexing section</a>, Stan supports multiple indexing.
Multiple indexes can be integer arrays of indexes, lower
bounds, upper bounds, lower and upper bounds, or simply shorthand for
all of the indexes. A complete table of index types is given in the
<a href="expressions.html#index-types-table">indexing options table</a>.</p>
<p><strong>Indexing Options Table.</strong> <a id="index-types-table"></a>
<em>Types of indexes and examples with one-dimensional containers of size
<code>N</code> and an integer array <code>ii</code> of type <code>int[]</code> size <code>K</code>.</em></p>
<table>
<thead>
<tr class="header">
<th align="center">index type</th>
<th align="center">example</th>
<th align="center">value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">integer</td>
<td align="center"><code>a[11]</code></td>
<td align="center">value of <code>a</code> at index 11</td>
</tr>
<tr class="even">
<td align="center">integer array</td>
<td align="center"><code>a[ii]</code></td>
<td align="center"><code>a[ii[1]]</code>, …, <code>a[ii[K]]</code></td>
</tr>
<tr class="odd">
<td align="center">lower bound</td>
<td align="center"><code>a[3:]</code></td>
<td align="center"><code>a[3]</code>, …, <code>a[N]</code></td>
</tr>
<tr class="even">
<td align="center">upper bound</td>
<td align="center"><code>a[:5]</code></td>
<td align="center"><code>a[1]</code>, …, <code>a[5]</code></td>
</tr>
<tr class="odd">
<td align="center">range</td>
<td align="center"><code>a[2:7]</code></td>
<td align="center"><code>a[2]</code>, …, <code>a[7]</code></td>
</tr>
<tr class="even">
<td align="center">all</td>
<td align="center"><code>a[:]</code></td>
<td align="center"><code>a[1]</code>, …, <code>a[N]</code></td>
</tr>
<tr class="odd">
<td align="center">all</td>
<td align="center"><code>a[]</code></td>
<td align="center"><code>a[1]</code>, …, <code>a[N]</code></td>
</tr>
</tbody>
</table>
<div id="multiple-index-semantics" class="section level3 unnumbered">
<h3>Multiple Index Semantics</h3>
<p>The fundamental semantic rule for dealing with multiple indexes is the
following. If <code>idxs</code> is a multiple index, then it produces an
indexable position in the result. To evaluate that index position in
the result, the index is first passed to the multiple index, and the
resulting index used.</p>
<pre class="stan"><code>a[idxs, ...][i, ...] = a[idxs[i], ...][...]</code></pre>
<p>On the other hand, if <code>idx</code> is a single index, it reduces the
dimensionality of the output, so that</p>
<pre class="stan"><code>a[idx, ...] = a[idx][...]</code></pre>
<p>The only issue is what happens with matrices and vectors. Vectors
work just like arrays. Matrices with multiple row indexes and
multiple column indexes produce matrices. Matrices with multiple row
indexes and a single column index become (column) vectors. Matrices
with a single row index and multiple column indexes become row
vectors. The types are summarized in the
<a href="expressions.html#matrix-indexing-table">matrix indexing table</a>.</p>
<p><strong>Matrix Indexing Table.</strong> <a id="matrix-indexing-table"></a>
<em>Special rules for reducing matrices based on whether the argument is
a single or multiple index. Examples are for a matrix <code>a</code>, with
integer single indexes <code>i</code> and <code>j</code> and integer array multiple
indexes <code>is</code> and <code>js</code>. The same typing rules apply for all multiple
indexes.</em></p>
<table>
<thead>
<tr class="header">
<th align="center">example</th>
<th align="center">row index</th>
<th align="center">column index</th>
<th align="center">result type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>a[i]</code></td>
<td align="center">single</td>
<td align="center">n/a</td>
<td align="center">row vector</td>
</tr>
<tr class="even">
<td align="center"><code>a[is]</code></td>
<td align="center">multiple</td>
<td align="center">n/a</td>
<td align="center">matrix</td>
</tr>
<tr class="odd">
<td align="center"><code>a[i, j]</code></td>
<td align="center">single</td>
<td align="center">single</td>
<td align="center">real</td>
</tr>
<tr class="even">
<td align="center"><code>a[i, js]</code></td>
<td align="center">single</td>
<td align="center">multiple</td>
<td align="center">row vector</td>
</tr>
<tr class="odd">
<td align="center"><code>a[is, j]</code></td>
<td align="center">multiple</td>
<td align="center">single</td>
<td align="center">vector</td>
</tr>
<tr class="even">
<td align="center"><code>a[is, js]</code></td>
<td align="center">multiple</td>
<td align="center">multiple</td>
<td align="center">matrix</td>
</tr>
</tbody>
</table>
<p>Evaluation of matrices with multiple indexes is defined to respect the
following distributivity conditions.</p>
<pre class="stan"><code>m[idxs1, idxs2][i, j] = m[idxs1[i], idxs2[j]]
m[idxs, idx][j] = m[idxs[j], idx]
m[idx, idxs][j] = m[idx, idxs[j]]</code></pre>
<p>Evaluation of arrays of matrices and arrays of vectors or row vectors
is defined recursively, beginning with the array dimensions.</p>
</div>
</div>
<div id="function-application.section" class="section level2">
<h2><span class="header-section-number">6.9</span> Function Application</h2>
<p>Stan provides a range of built in mathematical and statistical
functions, which are documented in the built-in function documentation.</p>
<p>Expressions in Stan may consist of the name of function followed by a
sequence of zero or more argument expressions. For instance,
<code>log(2.0)</code> is the expression of type <code>real</code> denoting the
result of applying the natural logarithm to the value of the real
literal <code>2.0</code>.</p>
<p>Syntactically, function application has higher precedence than any of
the other operators, so that <code>y + log(x)</code> is interpreted as
<code>y + (log(x))</code>.</p>
<div id="type-signatures-and-result-type-inference" class="section level3 unnumbered">
<h3>Type Signatures and Result Type Inference</h3>
<p>Each function has a type signature which determines the allowable type
of its arguments and its return type. For instance, the function
signature for the logarithm function can be expressed as</p>
<pre><code>real log(real);</code></pre>
<p>and the signature for the <code>lmultiply</code> function is</p>
<p><code>real lmultiply(real,real);</code></p>
<p>A function is uniquely determined by its name and its sequence of
argument types. For instance, the following two functions are
different functions.</p>
<p><code>real mean(real[]);</code></p>
<p><code>real mean(vector);</code></p>
<p>The first applies to a one-dimensional array of real values and the
second to a vector.</p>
<p>The identity conditions for functions explicitly forbids having two
functions with the same name and argument types but different return
types. This restriction also makes it possible to infer the type of a
function expression compositionally by only examining the type of its
subexpressions.</p>
</div>
<div id="constants" class="section level3 unnumbered">
<h3>Constants</h3>
<p>Constants in Stan are nothing more than nullary (no-argument)
functions. For instance, the mathematical constants <span class="math inline">\(\pi\)</span> and <span class="math inline">\(e\)</span> are
represented as nullary functions named <code>pi()</code> and <code>e()</code>.
See the <a href="#built-in-constants.section">built-in constants section</a> for a list of built-in constants.</p>
</div>
<div id="type-promotion-and-function-resolution" class="section level3 unnumbered">
<h3>Type Promotion and Function Resolution</h3>
<p>Because of integer to real type promotion, rules must be established
for which function is called given a sequence of argument types. The
scheme employed by Stan is the same as that used by C++, which
resolves a function call to the function requiring the minimum number
of type promotions.</p>
<p>For example, consider a situation in which the following two function
signatures have been registered for <code>foo</code>.</p>
<pre><code>real foo(real,real);
int foo(int,int);</code></pre>
<p>The use of <code>foo</code> in the expression <code>foo(1.0,1.0)</code> resolves
to <code>foo(real,real)</code>, and thus the expression <code>foo(1.0,1.0)</code>
itself is assigned a type of <code>real</code>.</p>
<p>Because integers may be promoted to real values, the expression
<code>foo(1,1)</code> could potentially match either <code>foo(real,real)</code>
or <code>foo(int,int)</code>. The former requires two type promotions and
the latter requires none, so <code>foo(1,1)</code> is resolved to function
<code>foo(int,int)</code> and is thus assigned the type <code>int</code>.</p>
<p>The expression <code>foo(1,1.0)</code> has argument types <code>(int,real)</code>
and thus does not explicitly match either function signature. By
promoting the integer expression <code>1</code> to type <code>real</code>, it is
able to match <code>foo(real,real)</code>, and hence the type of the
function expression <code>foo(1,1.0)</code> is <code>real</code>.</p>
<p>In some cases (though not for any built-in Stan functions), a
situation may arise in which the function referred to by an
expression remains ambiguous. For example, consider a situation in
which there are exactly two functions named <code>bar</code> with the
following signatures.</p>
<pre><code>real bar(real,int);
real bar(int,real);</code></pre>
<p>With these signatures, the expression <code>bar(1.0,1)</code> and
<code>bar(1,1.0)</code> resolve to the first and second of the above
functions, respectively. The expression <code>bar(1.0,1.0)</code> is
illegal because real values may not be demoted to integers. The
expression <code>bar(1,1)</code> is illegal for a different reason. If the
first argument is promoted to a real value, it matches the first
signature, whereas if the second argument is promoted to a real value,
it matches the second signature. The problem is that these both
require one promotion, so the function name <code>bar</code> is ambiguous.
If there is not a unique function requiring fewer promotions than all
others, as with <code>bar(1,1)</code> given the two declarations above,
the Stan compiler will flag the expression as illegal.</p>
</div>
<div id="random-number-generating-functions" class="section level3 unnumbered">
<h3>Random-Number Generating Functions</h3>
<p>For most of the distributions supported by Stan, there is a
corresponding random-number generating function. These random number
generators are named by the distribution with the suffix <code>_rng</code>.
For example, a univariate normal random number can be generated by
<code>normal_rng(0,1)</code>; only the parameters of the distribution,
here a location (0) and scale (1) are specified because the variate is
generated.</p>
<div id="random-number-generators-locations" class="section level4 unnumbered">
<h4>Random-Number Generators Locations</h4>
<p>The use of random-number generating functions is restricted to the
transformed data and generated quantities blocks; attempts to use them
elsewhere will result in a parsing error with a diagnostic message.
They may also be used in the bodies of user-defined functions whose
names end in <code>_rng</code>.</p>
<p>This allows the random number generating functions to be used for
simulation in general, and for Bayesian posterior predictive checking
in particular.</p>
</div>
<div id="posterior-predictive-checking" class="section level4 unnumbered">
<h4>Posterior Predictive Checking</h4>
<p>Posterior predictive checks typically use the parameters of the model
to generate simulated data (at the individual and optionally at the
group level for hierarchical models), which can then be compared
informally using plots and formally by means of test statistics, to
the actual data in order to assess the suitability of the model; see
Chapter 6 of <span class="citation">(Gelman et al. <a href="#ref-GelmanEtAl:2013">2013</a>)</span> for more information on
posterior predictive checks.</p>
</div>
</div>
</div>
<div id="type-inference" class="section level2">
<h2><span class="header-section-number">6.10</span> Type Inference</h2>
<p>Stan is strongly statically typed, meaning that the implementation
type of an expression can be resolved at compile time.</p>
<div id="implementation-types" class="section level3 unnumbered">
<h3>Implementation Types</h3>
<p>The primitive implementation types for Stan are</p>
<pre><code>int, real, vector, row_vector,  matrix.</code></pre>
<p>Every basic declared type corresponds to a primitive type; see the
<a href="expressions.html#primitive-type-table">primitive type table</a> for the mapping from types to their
primitive types.</p>
<p><strong>Primitive Type Table.</strong> <a id="primitive-type-table"></a>
<em>The table shows the variable declaration types of Stan
and their corresponding primitive implementation type. Stan
functions, operators, and probability functions have argument and
result types declared in terms of primitive types plus array
dimensionality.</em></p>
<table>
<thead>
<tr class="header">
<th align="left">type</th>
<th align="left">primitive type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>int</code></td>
<td align="left"><code>int</code></td>
</tr>
<tr class="even">
<td align="left"><code>real</code></td>
<td align="left"><code>real</code></td>
</tr>
<tr class="odd">
<td align="left"><code>matrix</code></td>
<td align="left"><code>matrix</code></td>
</tr>
<tr class="even">
<td align="left"><code>cov_matrix</code></td>
<td align="left"><code>matrix</code></td>
</tr>
<tr class="odd">
<td align="left"><code>corr_matrix</code></td>
<td align="left"><code>matrix</code></td>
</tr>
<tr class="even">
<td align="left"><code>cholesky_factor_cov</code></td>
<td align="left"><code>matrix</code></td>
</tr>
<tr class="odd">
<td align="left"><code>cholesky_factor_corr</code></td>
<td align="left"><code>matrix</code></td>
</tr>
<tr class="even">
<td align="left"><code>vector</code></td>
<td align="left"><code>vector</code></td>
</tr>
<tr class="odd">
<td align="left"><code>simplex</code></td>
<td align="left"><code>vector</code></td>
</tr>
<tr class="even">
<td align="left"><code>unit_vector</code></td>
<td align="left"><code>vector</code></td>
</tr>
<tr class="odd">
<td align="left"><code>ordered</code></td>
<td align="left"><code>vector</code></td>
</tr>
<tr class="even">
<td align="left"><code>positive_ordered</code></td>
<td align="left"><code>vector</code></td>
</tr>
<tr class="odd">
<td align="left"><code>row_vector</code></td>
<td align="left"><code>row_vector</code></td>
</tr>
</tbody>
</table>
<p>A full implementation type consists of a primitive implementation type
and an integer array dimensionality greater than or equal to zero.
These will be written to emphasize their array-like nature. For
example, <code>int[]</code> has an array dimensionality of 1, <code>int</code> an
array dimensionality of 0, and <code>int[ , ,]</code> an array dimensionality
of 3. The implementation type <code>matrix[ , , ]</code> has a total of five
dimensions and takes up to five indices, three from the array and two
from the matrix.</p>
<p>Recall that the array dimensions come before the matrix or vector
dimensions in an expression such as the following declaration of a
three-dimensional array of matrices.</p>
<pre class="stan"><code>matrix[M, N] a[I, J, K];</code></pre>
<p>The matrix <code>a</code> is indexed as <code>a[i, j, k, m, n]</code> with the array
indices first, followed by the matrix indices, with <code>a[i, j, k]</code>
being a matrix and <code>a[i, j, k, m]</code> being a row vector.</p>
</div>
<div id="type-inference-rules" class="section level3 unnumbered">
<h3>Type Inference Rules</h3>
<p>Stan’s type inference rules define the implementation type of an
expression based on a background set of variable declarations. The
rules work bottom up from primitive literal and variable expressions
to complex expressions.</p>
<div id="literals" class="section level4 unnumbered">
<h4>Literals</h4>
<p>An integer literal expression such as <code>42</code> is of type <code>int</code>.
Real literals such as <code>42.0</code> are of type <code>real</code>.</p>
</div>
<div id="variables" class="section level4 unnumbered">
<h4>Variables</h4>
<p>The type of a variable declared locally or in a previous block is
determined by its declaration. The type of a loop variable is
<code>int</code>.</p>
<p>There is always a unique declaration for each variable in each scope
because Stan prohibits the redeclaration of an already-declared
variables.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
</div>
<div id="indexing" class="section level4 unnumbered">
<h4>Indexing</h4>
<p>If <code>x</code> is an expression of total dimensionality greater than or equal
to <span class="math inline">\(N\)</span>, then the type of expression <code>e[i1, ..., iN]</code> is the same as
that of <code>e[i1]...[iN]</code>, so it suffices to define the type of a
singly-indexed function. Suppose <code>e</code> is an expression and <code>i</code> is an
expression of primitive type <code>int</code>. Then</p>
<ul>
<li><p>if <code>e</code> is an expression of array dimensionality <span class="math inline">\(K &gt; 0\)</span>, then <code>e[i]</code>
has array dimensionality <span class="math inline">\(K-1\)</span> and the same primitive implementation
type as <code>e</code>,</p></li>
<li><p>if <code>e</code> has implementation type <code>vector</code> or <code>row_vector</code> of array
dimensionality 0, then <code>e[i]</code> has implementation type <code>real</code>, and</p></li>
<li><p>if <code>e</code> has implementation type <code>matrix</code>, then <code>e[i]</code> has type
<code>row_vector</code>.</p></li>
</ul>
</div>
<div id="function-application" class="section level4 unnumbered">
<h4>Function Application</h4>
<p>If <code>f</code> is the name of a function and <code>e1,...,eN</code> are
expressions for <span class="math inline">\(N \geq 0\)</span>, then <code>f(e1,...,eN)</code> is an expression
whose type is determined by the return type in the function signature
for <code>f</code> given <code>e1</code> through <code>eN</code>. Recall that a
function signature is a declaration of the argument types and the
result type.</p>
<p>In looking up functions, binary operators like <code>real * real</code> are
defined as <code>operator*(real,real)</code> in the documentation and index.</p>
<p>In matching a function definition, arguments of type <code>int</code> may be
promoted to type <code>real</code> if necessary (see the subsection on type
promotion in <a href="expressions.html#function-application">the function application section</a> for an exact
specification of Stan’s integer-to-real type-promotion rule).</p>
<p>In general, matrix operations return the lowest inferable type. For
example, <code>row_vector * vector</code> returns a value of type
<code>real</code>, which is declared in the function documentation and index
as <code>real operator*(row_vector,vector)</code>.</p>
</div>
</div>
</div>
<div id="higher-order-functions" class="section level2">
<h2><span class="header-section-number">6.11</span> Higher-Order Functions</h2>
<p>There are several expression constructions in Stan that act as
higher-order functions.<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></p>
<p>The higher-order functions and the signature of their argument
functions are listed in the <a href="expressions.html#higher-order-functions-table">higher-order functions
table</a>.</p>
<p><strong>Higher-order Functions Table.</strong>
<a id="higher-order-functions-table"></a>
<em>Higher-order functions in Stan with their argument
function types. The first group of arguments has no restrictions.
The second group of arguments, consisting of a real and integer
array in all cases, must be expressions involving only data and
literals.</em></p>
<table>
<thead>
<tr class="header">
<th align="right">function</th>
<th align="center">unrestricted args</th>
<th align="center">data args</th>
<th align="center">return type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right"><code>algebra_solver</code></td>
<td align="center"><code>vector, vector</code></td>
<td align="center"><code>real[], int[]</code></td>
<td align="center"><code>vector</code></td>
</tr>
<tr class="even">
<td align="right"><code>integrate_ode_X</code>,</td>
<td align="center"><code>real, real[], real[]</code></td>
<td align="center"><code>real[], int[]</code></td>
<td align="center"><code>real[]</code></td>
</tr>
<tr class="odd">
<td align="right"><code>map_rect</code></td>
<td align="center"><code>vector, vector</code></td>
<td align="center"><code>real[], int[]</code></td>
<td align="center"><code>vector</code></td>
</tr>
</tbody>
</table>
<p>For example, the rectangular mapping function might be used in the
following way to compute the log likelihood of a hierarchical model.</p>
<pre class="stan"><code>functions {
  vector foo_ll(vector phi, vector theta, real[] x_r, int[] x_i) {
    ...
...
vector[11] phi;
vector[2] thetas[N];
real x_rs[N, 5];
real x_is[N, 0];
...
target += sum(map_rect(foo_ll, phi, thetas, x_rs, x_is));</code></pre>
<p>The function argument is <code>foo</code>, the name of the user-defined
function; as shown in the <a href="expressions.html#higher-order-functions">higher-order functions table</a>, <code>foo</code>
takes two vectors, a real array, and an integer array as arguments and
returns a vector.</p>
<div id="functions-passed-by-reference" class="section level3 unnumbered">
<h3>Functions Passed by Reference</h3>
<p>The function argument to higher-order functions is always passed as
the first argument. This function argument must be provided as the
name of a user-defined or built-in function. No quotes are
necessary.</p>
</div>
<div id="data-restricted-arguments" class="section level3 unnumbered">
<h3>Data-Restricted Arguments</h3>
<p>Some of the arguments to higher-order functions are restricted to
data. This means they must be expressions containing only data
variables, transformed data variables, or literals; the may contain
arbitrary functions applied to data variables or literals, but must
not contain parameters, transformed parameters, or local variables
from any block other than transformed data.</p>
<p>For user-defined functions the qualifier <code>data</code> may be prepended
to the type to restrict the argument to data-only variables.</p>
</div>
</div>
<div id="chain-rule-and-derivatives" class="section level2">
<h2><span class="header-section-number">6.12</span> Chain Rule and Derivatives</h2>
<p>Derivatives of the log probability function defined by a model are
used in several ways by Stan. The Hamiltonian Monte Carlo samplers,
including NUTS, use gradients to guide updates. The BFGS optimizers
also use gradients to guide search for posterior modes.</p>
<div id="errors-due-to-chain-rule" class="section level3 unnumbered">
<h3>Errors Due to Chain Rule</h3>
<p>Unlike evaluations in pure mathematics, evaluation of derivatives in
Stan is done by applying the chain rule on an expression-by-expression
basis, evaluating using floating-point arithmetic. As a result,
models such as the following are problematic for inference involving
derivatives.</p>
<pre class="stan"><code>parameters {
  real x;
}
model {
  x ~ normal(sqrt(x - x), 1);
}</code></pre>
<p>Algebraically, the sampling statement in the model could be reduced to</p>
<pre class="stan"><code>  x ~ normal(0, 1);</code></pre>
<p>and it would seem the model should produce unit normal draws for
<code>x</code>. But rather than canceling, the expression <code>sqrt(x -   x)</code> causes a problem for derivatives. The cause is the mechanistic
evaluation of the chain rule,</p>
<p><span class="math display">\[
\begin{array}{rcl}
\frac{d}{dx} \sqrt{x - x}
&amp; = &amp;
\frac{1}{2 \sqrt{x - x}} \times \frac{d}{dx} (x - x)
\\[4pt]
&amp; = &amp;
\frac{1}{0} \times (1 - 1)
\\[4pt]
&amp; = &amp;
\infty \times 0
\\[4pt]
&amp; = &amp; \mathrm{NaN}.
\end{array}
\]</span></p>
<p>Rather than the <span class="math inline">\(x - x\)</span> canceling out, it introduces a 0 into the
numerator and denominator of the chain-rule evaluation.</p>
<p>The only way to avoid this kind problem is to be careful to do the
necessary algebraic reductions as part of the model and not introduce
expressions like <code>sqrt(x - x)</code> for which the chain rule produces
not-a-number values.</p>
</div>
<div id="diagnosing-problems-with-derivatives" class="section level3 unnumbered">
<h3>Diagnosing Problems with Derivatives</h3>
<p>The best way to diagnose whether something is going wrong with the
derivatives is to use the test-gradient option to the sampler or
optimizer inputs; this option is available in both Stan and RStan
(though it may be slow, because it relies on finite differences to
make a comparison to the built-in automatic differentiation).</p>
<p>For example, compiling the above model to an executable
<code>sqrt-x-minus-x</code> in CmdStan, the test can be run as</p>
<pre><code>&gt; ./sqrt-x-minus-x diagnose test=gradient</code></pre>
<p>which produces</p>
<pre><code>...
TEST GRADIENT MODE

 Log probability=-0.393734

 param idx           value           model     finite diff           error
         0       -0.887393             nan               0             nan</code></pre>
<p>Even though finite differences calculates the right gradient of 0,
automatic differentiation follows the chain rule and produces a
not-a-number output.</p>

</div>
</div>
</div>
<h3><i style="font-size: 110%; color:#990017;">References</i></h3>
<div id="refs" class="references">
<div id="ref-GelmanEtAl:2013">
<p>Gelman, Andrew, J. B. Carlin, Hal S. Stern, David B. Dunson, Aki Vehtari, and Donald B. Rubin. 2013. <em>Bayesian Data Analysis</em>. Third. London: Chapman &amp;Hall/CRC Press.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="3">
<li id="fn3"><p>Languages such as C++ and R allow the declaration of a variable of a given name in a narrower scope to hide (take precedence over for evaluation) a variable defined in a containing scope.<a href="expressions.html#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>Internally, they are implemented as their own expression types because Stan doesn’t have object-level functional types (yet).<a href="expressions.html#fnref4" class="footnote-back">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="data-types-chapter.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="statements.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": null,
"fontsettings": {
"theme": "white",
"family": "serif",
"size": 2
},
"edit": null,
"download": null,
"toc": {
"collapse": "section",
"scroll_highlight": true
},
"search": false,
"toolbar": {
"position": "static"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
